<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kretz Multi-Track Analog Drum Machine v2.16 beta </title> <!-- Updated Title -->
  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.min.css"
    rel="stylesheet"
  />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.min.js"></script>
  <style>
    /* Styles remain largely the same */
     body { background-color: #121212; color: #ffffff; font-family: "Roboto", sans-serif; margin: 0; padding: 20px; }
    .container { max-width: 1400px; margin: 0 auto; }
    .instructions { background-color: #1E1E1E; padding: 20px; border-radius: 4px; margin-bottom: 20px; }
    .top-button-bar { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 20px; }
    .control-group { background-color: #1E1E1E; padding: 20px; border-radius: 4px; }
    .control-group.disabled-group { opacity: 0.5; pointer-events: none; user-select: none; }
    .control-group.disabled-group h3 { color: #888; }
    .control-group.disabled-group .slider-label span, .control-group.disabled-group label { color: #888; }
    .visualization { background-color: #1E1E1E; padding: 20px; border-radius: 4px; margin-bottom: 20px; }
    canvas { width: 100%; height: 150px; background-color: #2E2E2E; border-radius: 4px; }
    .slider-container { margin: 8px 0; }
    .slider-label { display: flex; justify-content: space-between; margin-bottom: 4px; align-items: center; font-size: 0.9em; }
    .slider-label span { margin-right: 6px; }
    .slider-label input[type="number"] { width: 65px; margin-left: 8px; background: #2F2F2F; color: #FFF; border: 1px solid #444; border-radius: 3px; padding: 3px; font-size: 0.9em; -moz-appearance: textfield; }
    .slider-label input[type="number"]::-webkit-outer-spin-button, .slider-label input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="range"] { width: 100%; background: #424242; height: 18px; -webkit-appearance: none; appearance: none; border-radius: 3px; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #BB86FC; border-radius: 50%; cursor: pointer; }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #BB86FC; border-radius: 50%; cursor: pointer; border: none; }
    select { width: 100%; padding: 8px; background-color: #424242; color: white; border: none; border-radius: 4px; }
    button { background-color: #BB86FC; color: #000000; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-right: 5px; margin-bottom: 5px; min-height: 34px; line-height: 1.4; font-size: 0.9em; transition: background-color 0.15s ease; }
    button:hover { background-color: #9965F4; } button:active { background-color: #6a42b8; }
    #loadStateBtn { background-color: #4a4a4a; color: #cccccc; } #loadStateBtn:hover { background-color: #6a42b8; color: #ffffff; }
    .footer { text-align: right; margin-top: 20px; color: #888888; }
    .normalize-container { margin-top: 15px; }
    .sequencer-container { background-color: #1E1E1E; padding: 20px; border-radius: 4px; margin-bottom: 20px; overflow-x: auto; }
    .track-selector { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #444; display: flex; align-items: center; flex-wrap: wrap; gap: 0px; }
    .track-selector strong { margin-right: 10px; margin-bottom: 5px; }
    .track-select-btn { background-color: #444; color: #ccc; padding: 5px 10px; min-height: 28px; font-size: 0.85em; border-top-right-radius: 0; border-bottom-right-radius: 0; margin-right: 0; }
    .track-select-btn.active { background-color: #BB86FC; color: #000; }
    .mute-btn, .solo-btn { padding: 5px 8px; min-height: 28px; font-size: 0.8em; margin-left: 0; border-top-left-radius: 0; border-bottom-left-radius: 0; border-top-right-radius: 0; border-bottom-right-radius: 0; font-weight: bold; line-height: 1; }
    .mute-btn { background-color: #555; color: #ccc; margin-right: 0px; }
    .solo-btn { background-color: #555; color: #ccc; margin-right: 8px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; }
    .mute-btn.muted { background-color: #e04f4f; color: #fff; } .mute-btn:hover { background-color: #777; } .mute-btn.muted:hover { background-color: #c73e3e; }
    .solo-btn.soloed { background-color: #4CAF50; color: #fff; } .solo-btn:hover { background-color: #777; } .solo-btn.soloed:hover { background-color: #45a049; }
    .sequencer-grid { display: grid; grid-template-columns: 45px repeat(32, minmax(28px, 1fr)); gap: 3px; margin-top: 10px; min-width: 1050px; }
    .track-label { grid-column: 1 / 2; text-align: right; padding-right: 8px; font-weight: bold; display: flex; align-items: center; justify-content: flex-end; font-size: 0.8em; color: #aaa; }
    .step { cursor: pointer; background-color: #333; color: #FFF; text-align: center; padding: 1px 2px; border: 1px solid #555; border-radius: 3px; user-select: none; position: relative; min-height: 32px; font-size: 0.6em; display: flex; flex-direction: column; justify-content: space-between; align-items: center; transition: background-color 0.1s ease, border-color 0.1s ease; overflow: hidden; }
    .step-top { font-size: 1.1em; line-height: 1; }
    .step-bottom { display: flex; width: 100%; justify-content: space-around; align-items: baseline; }
    .velocity-value { font-size: 0.8em; opacity: 0.9; display: block; line-height: 1; }
    .pitch-offset-value { font-size: 0.8em; opacity: 0.7; color: #ccc; display: block; line-height: 1; }
    .step.active { background-color: #BB86FC; color: #000; }
    .step.active .pitch-offset-value { color: #333; }
    .step:hover { border-color: #BB86FC; background-color: #404040; }
    .step.active:hover { background-color: #9965F4; }
    .step.disabled { background-color: #222 !important; border-color: #444 !important; color: #555 !important; pointer-events: none; opacity: 0.5; }
    .step.disabled .pitch-offset-value { color: #444 !important; }
    .step.playing { outline: 2px solid #FFF; outline-offset: -2px; background-color: #6f4fb6; /* Subtle playing highlight */ }
    hr { border: none; border-top: 1px solid #444; margin: 15px 0; }
    h3 { font-size: 1.1em; margin-bottom: 15px;}
    h4 { margin-top: 15px; margin-bottom: 10px; color: #ccc; font-size: 1em; border-top: 1px dashed #333; padding-top: 10px; }
    .control-group h4:first-of-type { margin-top: 0; border-top: none; padding-top: 0; }
    .slider-container.disabled-control { opacity: 0.5; pointer-events: none; user-select: none; }
    .slider-container.disabled-control .slider-label span { color: #888; }
    .oscillator-lfo-group { margin-top: 15px; padding-top: 10px; border-top: 1px solid #444; }
    .oscillator-lfo-group.disabled-control { opacity: 0.5; pointer-events: none; user-select: none; border-top-color: #333; }
    .oscillator-lfo-group.disabled-control h4 { color: #888; }
    .oscillator-lfo-group.disabled-control .slider-label span, .oscillator-lfo-group.disabled-control label { color: #888; }
    .pan-label::after { content: 'C'; } .pan-label.left::after { content: attr(data-pan-val) ' L'; } .pan-label.right::after { content: attr(data-pan-val) ' R'; }
    .slider-container > label { display: inline-block; margin-bottom: 6px; }
    .slider-container > select { margin-top: 0; }
     #punch-slider-container { /* Targeting the container */ }
     #punch-slider-container.disabled-control { opacity: 0.5; pointer-events: none; user-select: none; }
     #punch-slider-container.disabled-control .slider-label span { color: #888; }
  </style>
</head>
<body>
    <div class="container">
    <!-- Top Button Bar -->
    <div class="top-button-bar">
      <button id="playTopBtn">Play Selected Track</button>
      <button id="generateTopBtn">Generate Selected Track WAV</button>
      <button id="seqPlayTopBtn">Play Sequence</button>
      <button id="seqStopTopBtn">Stop Sequence</button>
      <button id="seqExportTopBtn">Export Sequence WAV</button>
      <button id="saveStateBtn">Save State (.krtz)</button>
      <button id="loadStateBtn">Load State (.krtz)</button>
      <input type="file" id="loadFileInput" accept=".krtz" style="display: none;" />
    </div>

    <div class="instructions">
       <h2>Kretz Multi-Track Analog Drum Machine v2.16 beta</h2> <!-- Updated Title -->
       <p>Refocused on stability. Flanger added, save/load fixed. Includes lookahead scheduler.</p> <!-- Updated Text -->
       <!-- Track Selector -->
       <div class="track-selector">
        <strong>Edit Track:</strong>
        <button class="track-select-btn active" data-track-index="0" id="track-select-0">T1</button><button class="mute-btn" data-track-index="0" id="mute-btn-0" title="Mute T1">M</button><button class="solo-btn" data-track-index="0" id="solo-btn-0" title="Solo T1">S</button>
        <button class="track-select-btn" data-track-index="1" id="track-select-1">T2</button><button class="mute-btn" data-track-index="1" id="mute-btn-1" title="Mute T2">M</button><button class="solo-btn" data-track-index="1" id="solo-btn-1" title="Solo T2">S</button>
        <button class="track-select-btn" data-track-index="2" id="track-select-2">T3</button><button class="mute-btn" data-track-index="2" id="mute-btn-2" title="Mute T3">M</button><button class="solo-btn" data-track-index="2" id="solo-btn-2" title="Solo T3">S</button>
        <button class="track-select-btn" data-track-index="3" id="track-select-3">T4</button><button class="mute-btn" data-track-index="3" id="mute-btn-3" title="Mute T4">M</button><button class="solo-btn" data-track-index="3" id="solo-btn-3" title="Solo T4">S</button>
        <button class="track-select-btn" data-track-index="4" id="track-select-4">T5</button><button class="mute-btn" data-track-index="4" id="mute-btn-4" title="Mute T5">M</button><button class="solo-btn" data-track-index="4" id="solo-btn-4" title="Solo T5">S</button>
        <button class="track-select-btn" data-track-index="5" id="track-select-5">T6</button><button class="mute-btn" data-track-index="5" id="mute-btn-5" title="Mute T6">M</button><button class="solo-btn" data-track-index="5" id="solo-btn-5" title="Solo T6">S</button>
        <button class="track-select-btn" data-track-index="6" id="track-select-6">T7</button><button class="mute-btn" data-track-index="6" id="mute-btn-6" title="Mute T7">M</button><button class="solo-btn" data-track-index="6" id="solo-btn-6" title="Solo T7">S</button>
        <button class="track-select-btn" data-track-index="7" id="track-select-7">T8</button><button class="mute-btn" data-track-index="7" id="mute-btn-7" title="Mute T8">M</button><button class="solo-btn" data-track-index="7" id="solo-btn-7" title="Solo T8">S</button>
      </div>
    </div>

    <div class="controls">
      <!-- Oscillator Section -->
      <div class="control-group" id="oscillator-group">
        <h3>Oscillator</h3>
        <div class="slider-container"> <label for="waveform">Waveform</label> <select id="waveform"> <option value="sine" selected>Sine</option> <option value="square">Square</option> <option value="sawtooth">Sawtooth</option> <option value="noise">Noise</option> <option value="random">Random</option> </select> </div>
         <div class="slider-container" id="punch-slider-container"> <div class="slider-label"> <span>Punch Amt</span><span id="punchValue">0 %</span> <input type="number" id="punchInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="punch" min="0" max="100" step="1" value="0" /> </div>
         <h4>Pitch</h4>
        <div class="slider-container" data-pitch-control> <div class="slider-label"> <span>Octave (C-3 → C5)</span> <span id="octaveLabel">C1</span> </div> <input type="range" id="octaveSlider" min="0" max="8" value="4"/> </div>
        <div class="slider-container" data-pitch-control> <div class="slider-label"> <span>Pitch (Fine)</span> <span id="pitchValue">500 Hz</span> <input type="number" id="pitchInput" min="0" max="15000" step="1" value="500"/> </div> <input type="range" id="pitch" min="0" max="15000" step="1" value="500" /> </div>
        <div class="oscillator-lfo-group" id="osc-lfo-subgroup">
            <h4>Oscillator LFO (Vibrato)</h4>
            <div class="slider-container"> <label for="oscLfoShape">Shape</label> <select id="oscLfoShape"> <option value="sine" selected>Sine</option> <option value="square">Square</option> <option value="sawtooth">Sawtooth</option> <option value="triangle">Triangle</option> </select> </div>
            <div class="slider-container"> <div class="slider-label"> <span>Rate (Hz)</span><span id="oscLfoRateValue">5.0 Hz</span> <input type="number" id="oscLfoRateInput" min="0.1" max="30" step="0.1" value="5.0"/> </div> <input type="range" id="oscLfoRate" min="0.1" max="30" step="0.1" value="5.0" /> </div>
            <div class="slider-container"> <div class="slider-label"> <span>Amount (%)</span><span id="oscLfoAmountValue">0 %</span> <input type="number" id="oscLfoAmountInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="oscLfoAmount" min="0" max="100" step="1" value="0" /> </div>
        </div>
      </div>
      <!-- Amplitude Envelope -->
      <div class="control-group"> <h3>Amplitude Env</h3> <div class="slider-container"> <div class="slider-label"> <span>Attack</span><span id="ampAttackValue">1 ms</span> <input type="number" id="ampAttackInput" min="0" max="1000" step="1" value="1"/> </div> <input type="range" id="ampAttack" min="0" max="1000" step="1" value="1" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Decay</span><span id="ampDecayValue">150 ms</span> <input type="number" id="ampDecayInput" min="0" max="1000" step="1" value="150"/> </div> <input type="range" id="ampDecay" min="0" max="1000" step="1" value="150" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Sustain Lvl</span><span id="ampSustainValue">0</span> <input type="number" id="ampSustainInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="ampSustain" min="0" max="100" step="1" value="0" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Release</span><span id="ampReleaseValue">200 ms</span> <input type="number" id="ampReleaseInput" min="0" max="2000" step="1" value="200"/> </div> <input type="range" id="ampRelease" min="0" max="2000" step="1" value="200" /> </div> </div>
      <!-- Filters -->
      <div class="control-group"> <h3>Filters</h3>
        <h4>Lowpass</h4>
        <div class="slider-container"> <div class="slider-label"> <span>LP Cutoff</span><span id="cutoffValue">5000 Hz</span> <input type="number" id="cutoffInput" min="20" max="10000" step="1" value="5000"/> </div> <input type="range" id="cutoff" min="20" max="10000" step="1" value="5000" /> </div> <div class="slider-container"> <div class="slider-label"> <span>LP Res</span><span id="resonanceValue">5.0</span> <input type="number" id="resonanceInput" min="0" max="20" step="0.1" value="5"/> </div> <input type="range" id="resonance" min="0" max="20" step="0.1" value="5" /> </div> <div class="slider-container"> <div class="slider-label"> <span>LP Env Amt</span><span id="filterEnvValue">50</span> <input type="number" id="filterEnvInput" min="0" max="100" step="1" value="50"/> </div> <input type="range" id="filterEnv" min="0" max="100" step="1" value="50" /> </div>
        <h4>Highpass</h4>
        <div class="slider-container"> <div class="slider-label"> <span>HP Cutoff</span><span id="hpCutoffValue">20 Hz</span> <input type="number" id="hpCutoffInput" min="20" max="10000" step="1" value="20"/> </div> <input type="range" id="hpCutoff" min="20" max="10000" step="1" value="20" /> </div> <div class="slider-container"> <div class="slider-label"> <span>HP Res</span><span id="hpResonanceValue">0.0</span> <input type="number" id="hpResonanceInput" min="0" max="20" step="0.1" value="0"/> </div> <input type="range" id="hpResonance" min="0" max="20" step="0.1" value="0" /> </div> <div class="slider-container"> <div class="slider-label"> <span>HP Env Amt</span><span id="hpFilterEnvValue">0</span> <input type="number" id="hpFilterEnvInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="hpFilterEnv" min="0" max="100" step="1" value="0" /> </div>
      </div>
      <!-- Pitch Envelope -->
      <div class="control-group" id="pitch-envelope-group"> <h3>Pitch Env</h3> <div class="slider-container"> <div class="slider-label"> <span>Amount (%)</span><span id="pitchEnvAmountValue">50</span> <input type="number" id="pitchEnvAmountInput" min="0" max="100" step="1" value="50"/> </div> <input type="range" id="pitchEnvAmount" min="0" max="100" step="1" value="50" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Speed (%)</span><span id="pitchSpeedLabel">0%</span> <input type="number" id="pitchSpeedInput" min="-100" max="100" step="1" value="0"/> </div> <input type="range" id="pitchSpeed" min="-100" max="100" step="1" value="0" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Attack</span><span id="pitchAttackValue">1 ms</span> <input type="number" id="pitchAttackInput" min="0" max="1000" step="1" value="1"/> </div> <input type="range" id="pitchAttack" min="0" max="1000" step="1" value="1" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Decay</span><span id="pitchDecayValue">100 ms</span> <input type="number" id="pitchDecayInput" min="0" max="1000" step="1" value="100"/> </div> <input type="range" id="pitchDecay" min="0" max="1000" step="1" value="100" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Sustain Lvl</span><span id="pitchSustainValue">0</span> <input type="number" id="pitchSustainInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="pitchSustain" min="0" max="100" step="1" value="0" /> </div> <div class="slider-container"> <div class="slider-label"> <span>Release</span><span id="pitchReleaseValue">100 ms</span> <input type="number" id="pitchReleaseInput" min="0" max="2000" step="1" value="100"/> </div> <input type="range" id="pitchRelease" min="0" max="2000" step="1" value="100" /> </div> </div>

      <!-- Track Effects & Sends -->
      <div class="control-group">
        <h3>Track Effects & Sends</h3>
        <div class="slider-container"> <div class="slider-label"> <span>Distortion</span><span id="distortionValue">0%</span> <input type="number" id="distortionInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="distortion" min="0" max="100" step="1" value="0" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Volume</span><span id="trackVolumeValue">100%</span> <input type="number" id="trackVolumeInput" min="0" max="100" step="1" value="100"/> </div> <input type="range" id="trackVolume" min="0" max="100" step="1" value="100" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Pan</span> <span id="panValue" class="pan-label">C</span> <input type="number" id="panInput" min="-100" max="100" step="1" value="0"/> </div> <input type="range" id="pan" min="-100" max="100" step="1" value="0" /> </div>
        <h4>Sends</h4>
        <div class="slider-container"> <div class="slider-label"> <span>Reverb Send</span><span id="reverbSendValue">0%</span> <input type="number" id="reverbSendInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="reverbSend" min="0" max="100" step="1" value="0" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Delay Send</span><span id="delaySendValue">0%</span> <input type="number" id="delaySendInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="delaySend" min="0" max="100" step="1" value="0" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Flanger Send</span><span id="flangerSendValue">0%</span> <input type="number" id="flangerSendInput" min="0" max="100" step="1" value="0"/> </div> <input type="range" id="flangerSend" min="0" max="100" step="1" value="0" /> </div>
      </div>

       <!-- Master Effects -->
      <div class="control-group">
        <h3>Master Effects</h3>
        <h4>Compressor</h4>
        <div class="slider-container"> <div class="slider-label"> <span>Comp Thresh</span><span id="compThresholdValue">-24 dB</span> <input type="number" id="compThresholdInput" min="-60" max="0" step="1" value="-24"/> </div> <input type="range" id="compThreshold" min="-60" max="0" step="1" value="-24" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Comp Ratio</span><span id="compRatioValue">12:1</span> <input type="number" id="compRatioInput" min="1" max="20" step="1" value="12"/> </div> <input type="range" id="compRatio" min="1" max="20" step="1" value="12" /> </div>
        <h4>Reverb</h4>
         <div class="slider-container"> <div class="slider-label"> <span>Pre-Delay (ms)</span><span id="masterReverbPreDelayValue">10 ms</span> <input type="number" id="masterReverbPreDelayInput" min="0" max="200" step="1" value="10"/> </div> <input type="range" id="masterReverbPreDelay" min="0" max="200" step="1" value="10" /> </div>
         <div class="slider-container"> <div class="slider-label"> <span>Tone (LPF Hz)</span><span id="masterReverbToneValue">5000 Hz</span> <input type="number" id="masterReverbToneInput" min="100" max="15000" step="10" value="5000"/> </div> <input type="range" id="masterReverbTone" min="100" max="15000" step="10" value="5000" /> </div>
         <div class="slider-container"> <div class="slider-label"> <span>Reverb Wet</span><span id="masterReverbWetValue">20%</span> <input type="number" id="masterReverbWetInput" min="0" max="100" step="1" value="20"/> </div> <input type="range" id="masterReverbWet" min="0" max="100" step="1" value="20" /> </div>
        <h4>Delay</h4>
         <div class="slider-container"> <label for="masterDelayDivision">Delay Time</label> <select id="masterDelayDivision"> <option value="1/16">1/16</option> <option value="1/16t">1/16t</option> <option value="1/16d">1/16d</option> <option value="1/8" selected>1/8</option> <option value="1/8t">1/8t</option> <option value="1/8d">1/8d</option> <option value="1/4">1/4</option> <option value="1/4t">1/4t</option> <option value="1/4d">1/4d</option> <option value="1/2">1/2</option> <option value="1/2t">1/2t</option> <option value="1/2d">1/2d</option> <option value="1/1">1/1</option> <option value="1/1t">1/1t</option> <option value="1/1d">1/1d</option> </select> <span id="masterDelayTimeSecondsLabel" style="font-size:0.8em; opacity: 0.7; margin-left: 10px;">(0.25s)</span> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Delay Fbk</span><span id="masterDelayFeedbackValue">40%</span> <input type="number" id="masterDelayFeedbackInput" min="0" max="95" step="1" value="40"/> </div> <input type="range" id="masterDelayFeedback" min="0" max="95" step="1" value="40" /> </div>
         <div class="slider-container"> <div class="slider-label"> <span>Delay Wet</span><span id="masterDelayWetValue">30%</span> <input type="number" id="masterDelayWetInput" min="0" max="100" step="1" value="30"/> </div> <input type="range" id="masterDelayWet" min="0" max="100" step="1" value="30" /> </div>
        <h4>Flanger</h4>
        <div class="slider-container"> <div class="slider-label"> <span>Rate (Hz)</span><span id="masterFlangerRateValue">0.30 Hz</span> <input type="number" id="masterFlangerRateInput" min="0.05" max="5" step="0.01" value="0.30"/> </div> <input type="range" id="masterFlangerRate" min="0.05" max="5" step="0.01" value="0.30" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Depth (ms)</span><span id="masterFlangerDepthValue">3.0 ms</span> <input type="number" id="masterFlangerDepthInput" min="0.1" max="10" step="0.1" value="3.0"/> </div> <input type="range" id="masterFlangerDepth" min="0.1" max="10" step="0.1" value="3.0" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Delay (ms)</span><span id="masterFlangerDelayValue">5.0 ms</span> <input type="number" id="masterFlangerDelayInput" min="1" max="20" step="0.1" value="5.0"/> </div> <input type="range" id="masterFlangerDelay" min="1" max="20" step="0.1" value="5.0" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Feedback (%)</span><span id="masterFlangerFeedbackValue">50 %</span> <input type="number" id="masterFlangerFeedbackInput" min="-90" max="90" step="1" value="50"/> </div> <input type="range" id="masterFlangerFeedback" min="-90" max="90" step="1" value="50" /> </div>
        <div class="slider-container"> <div class="slider-label"> <span>Flanger Wet</span><span id="masterFlangerWetValue">40%</span> <input type="number" id="masterFlangerWetInput" min="0" max="100" step="1" value="40"/> </div> <input type="range" id="masterFlangerWet" min="0" max="100" step="1" value="40" /> </div>

        <h4>Master Output</h4>
        <div class="slider-container"> <div class="slider-label"> <span>Master Vol</span><span id="masterVolumeValue">90%</span> <input type="number" id="masterVolumeInput" min="0" max="100" step="1" value="90"/> </div> <input type="range" id="masterVolume" min="0" max="100" step="1" value="90" /> </div>
        <div class="normalize-container"> <label> <input type="checkbox" id="normalizeCheckbox" checked /> Normalize Export </label> </div>
      </div>
    </div>

    <!-- Sequencer Section -->
    <div class="sequencer-container control-group">
        <h3>32-Step Sequencer (8 Tracks)</h3>
       <div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 15px;"> <div class="slider-container" style="flex: 1 1 200px;"> <div class="slider-label"> <span>Tempo</span> <span id="tempoValue">120 BPM</span> <input type="number" id="tempoInput" min="40" max="240" step="1" value="120"/> </div> <input type="range" id="tempo" min="40" max="240" step="1" value="120" /> </div> <div class="slider-container" style="flex: 1 1 200px;"> <div class="slider-label"> <span>Length</span> <span id="seqLengthLabel">32</span> <input type="number" id="seqLengthInput" min="1" max="32" step="1" value="32"/> </div> <input type="range" id="seqLength" min="1" max="32" step="1" value="32" /> </div> </div>
       <div class="sequencer-grid" id="sequencerGrid"></div>
       <div style="margin-top:15px;"> <button id="seqPlayBtn">Play Seq</button> <button id="seqStopBtn">Stop Seq</button> <button id="seqRandomBtn">Random Steps</button> <button id="seqRandomTonesBtn">Random Tones</button> <button id="seqClearBtn">Clear Steps</button> <button id="seqClearAllBtn">Clear All Tracks</button> <button id="seqExportBtn">Export Seq WAV</button> </div>
       <p style="font-size:0.9rem; margin-top:10px; opacity:0.8;"> L-Click: Toggle Step | R-Click: Clear Step | Drag V: Velocity | Shift+Drag V: Pitch Offset </p>
    </div>

    <!-- Oscilloscope & Other Controls -->
    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;"> <div class="visualization control-group" style="flex: 1 1 400px;"> <h3>Master Oscilloscope</h3> <canvas id="oscilloscope"></canvas> </div> <div class="control-group" style="flex: 0 1 300px;"> <h3>Scope Zoom</h3> <div class="slider-container"> <div class="slider-label"> <span>Zoom</span> <span id="scopeZoomLabel">1.0x</span> <input type="number" id="scopeZoomInput" min="0.1" max="10" step="0.1" value="1.0"/> </div> <input type="range" id="scopeZoom" min="0.1" max="10" step="0.1" value="1.0"/> </div> </div> </div>
    <div class="top-button-bar"> <button id="play">Play Selected Track</button> <button id="generate">Generate Selected Track WAV</button> </div>
    <div class="footer"> © Jonas Lund 2024 (Multi-Track Mod v2.16 beta) </div> <!-- Updated Footer -->
  </div>


<script>
    class DrumSynth {
        // Constants
        MAX_DELAY_TIME = 2.0;
        MAX_DELAY_FEEDBACK = 0.95;
        MAX_REVERB_PREDELAY = 0.5; // 500ms
        MAX_FLANGER_DELAY = 0.025; // 25ms max for flanger base delay

        // Default values
        DEFAULT_MASTER_VOLUME = 90;
        DEFAULT_REVERB_WET = 20;
        DEFAULT_REVERB_PREDELAY = 10; // ms
        DEFAULT_REVERB_TONE = 5000; // Hz
        DEFAULT_DELAY_DIVISION = '1/8';
        DEFAULT_DELAY_FEEDBACK = 40;
        DEFAULT_DELAY_WET = 30;
        DEFAULT_FLANGER_RATE = 0.3; // Hz
        DEFAULT_FLANGER_DEPTH_MS = 3.0; // ms
        DEFAULT_FLANGER_DELAY_MS = 5.0; // ms
        DEFAULT_FLANGER_FEEDBACK = 50; // % (-90 to +90 range)
        DEFAULT_FLANGER_WET = 40; // %

        // Sequencer Scheduling Properties
        schedulerInterval = null;
        scheduleAheadTime = 0.1;
        nextNoteTime = 0.0;
        notesInQueue = [];
        current16thNote = 0;


      constructor() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 48000, latencyHint: 'balanced'
            });
            console.log(`AudioContext created. State: ${this.audioContext.state}, SampleRate: ${this.audioContext.sampleRate}, Latency Hint: 'balanced', Base Latency: ${this.audioContext.baseLatency?.toFixed(4)}s`);

            const resumeAudio = () => { if (this.audioContext.state === "suspended") { this.audioContext.resume().then(() => console.log("AudioContext resumed.")).catch(e => console.error("Resume Error:", e)); } };
            document.addEventListener("click", resumeAudio, { once: true }); document.addEventListener("touchend", resumeAudio, { once: true });

            this.masterCompressor = this.audioContext.createDynamicsCompressor();
            this.masterGain = this.audioContext.createGain();
            this.analyser = this.audioContext.createAnalyser(); this.analyser.fftSize = 2048;
            this.masterGain.gain.value = this.DEFAULT_MASTER_VOLUME / 100.0;
            console.log(`Initial Master Gain set to: ${this.masterGain.gain.value}`);

            this.setupReverb();
            this.setupDelay();
            this.setupFlanger();

            this.masterCompressor.connect(this.masterGain);
            this.masterGain.connect(this.analyser);
            this.analyser.connect(this.audioContext.destination);
            console.log("Master audio chain connected.");

            this.noiseBuffer = this.createNoiseBuffer(this.audioContext); this.octaveFreqs = [ 2.04, 4.08, 8.18, 16.35, 32.70, 65.41, 130.81, 261.63, 523.25 ]; this.octaveLabels = [ "C-3", "C-2", "C-1", "C0", "C1", "C2", "C3", "C4", "C5" ];
            this.numTracks = 8; this.tracks = []; this.selectedTrackIndex = 0;
            this.isPlayingSeq = false;
            this.sequenceLength = 32; this.tempo = 120; this.scopeZoom = 1.0;
            this.saveFileVersion = "2.16"; // <-- Updated Version
            this.delayDivision = this.DEFAULT_DELAY_DIVISION;

             this.initTrackData();
             this.setupUI();
             this.updateDelayTimeBasedOnTempo();
             this.setupEventListeners();
             this.initSequencerUI();
             this.updateUIForTrack(this.selectedTrackIndex);
             this.updatePitchControlsState();
             this.updateSequenceLengthUI(this.sequenceLength);
             this.updateAllSoloMuteButtonsUI();
             this.drawScope();

        } catch (error) {
            console.error("FATAL Error during DrumSynth initialization:", error, error.stack);
            alert("Fatal error initializing synthesizer. Check console for details.");
            document.body.innerHTML = `<h2 style="color:red; padding: 20px;">Fatal Error Initializing Synth: ${error.message}. Check Console.</h2><pre>${error.stack}</pre>`;
        }
      }

      // --- Effect Setup Methods ---
      setupReverb() {
          try {
            this.reverbPreDelay = this.audioContext.createDelay(this.MAX_REVERB_PREDELAY);
            this.reverbNode = this.audioContext.createConvolver();
            this.reverbWetGain = this.audioContext.createGain();
            this.reverbToneFilter = this.audioContext.createBiquadFilter();
            this.reverbPreDelay.delayTime.value = this.DEFAULT_REVERB_PREDELAY / 1000.0;
            this.reverbWetGain.gain.value = this.DEFAULT_REVERB_WET / 100.0;
            this.reverbToneFilter.type = 'lowpass';
            this.reverbToneFilter.frequency.value = this.DEFAULT_REVERB_TONE;
            try { this.reverbNode.buffer = this.createSimpleIR(this.audioContext); } catch (irError) { console.error("Failed IR:", irError); }
            this.reverbPreDelay.connect(this.reverbNode);
            this.reverbNode.connect(this.reverbWetGain);
            this.reverbWetGain.connect(this.reverbToneFilter);
            this.reverbToneFilter.connect(this.masterCompressor);
             console.log("Reverb setup complete.");
          } catch(e) { console.error("Error setting up Reverb:", e); }
       }

      setupDelay() {
          try {
            this.delayNode = this.audioContext.createDelay(this.MAX_DELAY_TIME);
            this.delayFeedbackGain = this.audioContext.createGain();
            this.delayWetGain = this.audioContext.createGain();
            this.delayFeedbackGain.gain.value = this.DEFAULT_DELAY_FEEDBACK / 100.0;
            this.delayWetGain.gain.value = this.DEFAULT_DELAY_WET / 100.0;
            this.delayNode.connect(this.delayFeedbackGain);
            this.delayFeedbackGain.connect(this.delayNode);
            this.delayNode.connect(this.delayWetGain);
            this.delayWetGain.connect(this.masterCompressor);
             console.log("Delay setup complete.");
         } catch(e) { console.error("Error setting up Delay:", e); }
      }

      setupFlanger() {
          try {
             this.flangerInput = this.audioContext.createGain();
             this.flangerDelay = this.audioContext.createDelay(this.MAX_FLANGER_DELAY);
             this.flangerLFO = this.audioContext.createOscillator();
             this.flangerLFODepth = this.audioContext.createGain();
             this.flangerFeedback = this.audioContext.createGain();
             this.flangerWetGain = this.audioContext.createGain();

             this.flangerDelay.delayTime.value = this.DEFAULT_FLANGER_DELAY_MS / 1000.0;
             this.flangerLFO.type = 'sine';
             this.flangerLFO.frequency.value = this.DEFAULT_FLANGER_RATE;
             this.flangerLFODepth.gain.value = this.DEFAULT_FLANGER_DEPTH_MS / 1000.0;
             this.flangerFeedback.gain.value = this.DEFAULT_FLANGER_FEEDBACK / 100.0;
             this.flangerWetGain.gain.value = this.DEFAULT_FLANGER_WET / 100.0;

             this.flangerInput.connect(this.flangerDelay);
             this.flangerLFO.connect(this.flangerLFODepth);
             this.flangerLFODepth.connect(this.flangerDelay.delayTime);
             this.flangerDelay.connect(this.flangerFeedback);
             this.flangerFeedback.connect(this.flangerDelay);
             this.flangerDelay.connect(this.flangerWetGain);
             this.flangerWetGain.connect(this.masterCompressor);

             this.flangerLFO.start();
             console.log("Flanger setup complete.");
          } catch(e) { console.error("Error setting up Flanger:", e); }
      }

      // --- createSimpleIR, createNoiseBuffer ---
      createSimpleIR(context) { const sampleRate = context.sampleRate; const length = sampleRate * 1.5; const impulse = context.createBuffer(2, length, sampleRate); const L = impulse.getChannelData(0); const R = impulse.getChannelData(1); for (let i = 0; i < length; i++) { const decay = Math.pow(1 - (i / length), 3); L[i] = (Math.random() * 2 - 1) * decay; R[i] = (Math.random() * 2 - 1) * decay; } console.log("Generated simple IR buffer."); return impulse; }
      createNoiseBuffer(context) { const bufferSize = context.sampleRate * 2; const buffer = context.createBuffer(1, bufferSize, context.sampleRate); const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; } return buffer; }


      // --- getDefaultTrackParams, initTrackData ---
      getDefaultTrackParams(trackIndex) {
          const baseDefaults=[{waveform:'sine',pitch:60,octave:4,ampDecay:150,cutoff:5000,filterEnv:50,pitchDecay:100,pitchEnvAmount:50,distortion:0,trackVolume:100,hpCutoff:20,pitchSpeed:0},{waveform:'noise',pitch:10000,octave:8,ampDecay:80,cutoff:8000,filterEnv:0,pitchDecay:10,pitchEnvAmount:0,distortion:5,trackVolume:80,hpCutoff:3000,pitchSpeed:0},{waveform:'square',pitch:220,octave:5,ampDecay:300,cutoff:3000,filterEnv:30,pitchDecay:50,pitchEnvAmount:20,distortion:10,trackVolume:90,hpCutoff:100,pitchSpeed:0},{waveform:'noise',pitch:10000,octave:8,ampDecay:50,cutoff:9000,filterEnv:0,pitchDecay:5,pitchEnvAmount:0,distortion:0,trackVolume:70,hpCutoff:6000,pitchSpeed:0},]; const d=baseDefaults[trackIndex%baseDefaults.length]; let variationFactor=1.0; if(trackIndex>=4){variationFactor=1.0+(Math.random()*0.2-0.1);} let defaultPitch = Math.round(d.pitch*variationFactor); defaultPitch = Math.max(0, Math.min(15000, defaultPitch));
          return { waveform:d.waveform, octave:d.octave, pitch:defaultPitch, ampAttack:1,ampDecay:Math.round(d.ampDecay*variationFactor),ampSustain:0,ampRelease:100, cutoff:Math.round(d.cutoff*variationFactor),resonance:5,filterEnv:d.filterEnv, hpCutoff:Math.round(d.hpCutoff*variationFactor),hpResonance:0,hpFilterEnv:0, pitchEnvAmount:d.pitchEnvAmount,pitchAttack:1,pitchDecay:Math.round(d.pitchDecay*variationFactor),pitchSustain:0,pitchRelease:50,pitchSpeed:d.pitchSpeed, oscLfoShape: 'sine', oscLfoRate: 5.0, oscLfoAmount: 0, distortion:d.distortion,trackVolume:d.trackVolume, pan: 0, reverbSend: 0, delaySend: 0, flangerSend: 0, punch: 0 };
      }
      initTrackData() { this.tracks = []; for(let i = 0; i < this.numTracks; i++) { this.tracks.push({ id: i, name: `Track ${i + 1}`, params: this.getDefaultTrackParams(i), steps: Array(32).fill(null).map(() => ({ active: false, velocity: 100, pitchOffset: 0 })), isMuted: false, isSoloed: false }); } console.log("Track data initialized."); }

      // --- UI Update Functions ---
      updateUIForTrack(trackIndex) {
          if (trackIndex < 0 || trackIndex >= this.numTracks || !this.tracks[trackIndex]) return;
          try {
              const params = this.tracks[trackIndex].params;
              document.getElementById('waveform').value = params.waveform; this.updateSliderAndNumber('punch', 'punchInput', 'punchValue', params.punch || 0, ' %'); this.updateSliderAndNumber('octaveSlider', null, 'octaveLabel', params.octave, '', i => this.octaveLabels[i]); this.updateSliderAndNumber('pitch', 'pitchInput', 'pitchValue', params.pitch, ' Hz'); document.getElementById('oscLfoShape').value = params.oscLfoShape || 'sine'; this.updateSliderAndNumber('oscLfoRate', 'oscLfoRateInput', 'oscLfoRateValue', (params.oscLfoRate || 5.0).toFixed(1), ' Hz'); this.updateSliderAndNumber('oscLfoAmount', 'oscLfoAmountInput', 'oscLfoAmountValue', params.oscLfoAmount || 0, ' %');
              this.updateSliderAndNumber('ampAttack', 'ampAttackInput', 'ampAttackValue', params.ampAttack, ' ms'); this.updateSliderAndNumber('ampDecay', 'ampDecayInput', 'ampDecayValue', params.ampDecay, ' ms'); this.updateSliderAndNumber('ampSustain', 'ampSustainInput', 'ampSustainValue', params.ampSustain, ''); this.updateSliderAndNumber('ampRelease', 'ampReleaseInput', 'ampReleaseValue', params.ampRelease, ' ms');
              this.updateSliderAndNumber('cutoff', 'cutoffInput', 'cutoffValue', params.cutoff, ' Hz'); this.updateSliderAndNumber('resonance', 'resonanceInput', 'resonanceValue', params.resonance.toFixed(1), ''); this.updateSliderAndNumber('filterEnv', 'filterEnvInput', 'filterEnvValue', params.filterEnv, ''); this.updateSliderAndNumber('hpCutoff', 'hpCutoffInput', 'hpCutoffValue', params.hpCutoff, ' Hz'); this.updateSliderAndNumber('hpResonance', 'hpResonanceInput', 'hpResonanceValue', params.hpResonance.toFixed(1), ''); this.updateSliderAndNumber('hpFilterEnv', 'hpFilterEnvInput', 'hpFilterEnvValue', params.hpFilterEnv, '');
              this.updateSliderAndNumber('pitchEnvAmount', 'pitchEnvAmountInput', 'pitchEnvAmountValue', params.pitchEnvAmount, ''); this.updateSliderAndNumber('pitchSpeed', 'pitchSpeedInput', 'pitchSpeedLabel', params.pitchSpeed, '%'); this.updateSliderAndNumber('pitchAttack', 'pitchAttackInput', 'pitchAttackValue', params.pitchAttack, ' ms'); this.updateSliderAndNumber('pitchDecay', 'pitchDecayInput', 'pitchDecayValue', params.pitchDecay, ' ms'); this.updateSliderAndNumber('pitchSustain', 'pitchSustainInput', 'pitchSustainValue', params.pitchSustain, ''); this.updateSliderAndNumber('pitchRelease', 'pitchReleaseInput', 'pitchReleaseValue', params.pitchRelease, ' ms');
              this.updateSliderAndNumber('distortion', 'distortionInput', 'distortionValue', params.distortion, '%'); this.updateSliderAndNumber('trackVolume', 'trackVolumeInput', 'trackVolumeValue', params.trackVolume, '%');
              this.updatePanUI(params.pan !== undefined ? params.pan : 0);
              this.updateSliderAndNumber('reverbSend', 'reverbSendInput', 'reverbSendValue', params.reverbSend || 0, '%'); this.updateSliderAndNumber('delaySend', 'delaySendInput', 'delaySendValue', params.delaySend || 0, '%'); this.updateSliderAndNumber('flangerSend', 'flangerSendInput', 'flangerSendValue', params.flangerSend || 0, '%');
              document.querySelectorAll('.track-select-btn').forEach(btn => { btn.classList.toggle('active', parseInt(btn.dataset.trackIndex) === trackIndex); });
              this.selectedTrackIndex = trackIndex; this.updatePitchControlsState();
          } catch (error) { console.error(`Error updating UI for track ${trackIndex}:`, error); }
      }
      updatePanUI(panValue) { const value = parseInt(panValue) || 0; this.updateSliderAndNumber('pan', 'panInput', null, value, ''); const label = document.getElementById('panValue'); if(label) { label.classList.remove('left', 'right'); if (value === 0) { label.textContent = 'C'; } else if (value < 0) { label.textContent = `${Math.abs(value)}`; label.classList.add('left'); label.dataset.panVal = Math.abs(value); } else { label.textContent = `${value}`; label.classList.add('right'); label.dataset.panVal = value; } } }
      updateSliderAndNumber(sliderId, numberId, labelId, value, suffix = "", labelFormatter = null) { const slider = document.getElementById(sliderId); const number = numberId ? document.getElementById(numberId) : null; const label = labelId ? document.getElementById(labelId) : null; const numericValue = Number(value); if (isNaN(numericValue) && labelFormatter === null) { /* console.warn(`Invalid numeric value for ${sliderId || numberId || labelId}:`, value); */ return; } if (slider) slider.value = numericValue; if (number) number.value = value; if (label) { try { label.textContent = labelFormatter ? labelFormatter(value) : value + suffix; } catch (e) { console.error(`Error formatting label ${labelId}:`, e); label.textContent = "Err"; } } }
      syncAndStoreParam(sliderId, numberId, labelId, trackParamKey, suffix = "", isFloat = false, labelFormatter = null) { const slider = document.getElementById(sliderId); const number = numberId ? document.getElementById(numberId) : null; const label = labelId ? document.getElementById(labelId) : null; if (!slider && !number) { console.warn(`UI elements missing for param ${trackParamKey}.`); return; } const updateState = (newValueStr) => { try { if (this.selectedTrackIndex < 0 || this.selectedTrackIndex >= this.numTracks || !this.tracks[this.selectedTrackIndex]) return; let value = isFloat ? parseFloat(newValueStr) : parseInt(newValueStr); if (isNaN(value)) { console.warn(`Invalid input for ${trackParamKey}: '${newValueStr}'`); return; } const min = slider ? Number(slider.min) : (number ? Number(number.min) : -Infinity); const max = slider ? Number(slider.max) : (number ? Number(number.max) : Infinity); value = Math.max(min, Math.min(max, value)); const step = number?.step; const precision = (isFloat && (step === '0.1' || step === '0.01')) ? (step === '0.01' ? 2 : 1) : 0; const storedValue = isFloat ? Number(value.toFixed(precision)) : value; this.tracks[this.selectedTrackIndex].params[trackParamKey] = storedValue; const displayValue = isFloat ? storedValue.toFixed(precision) : storedValue; if (sliderId === 'pan') { this.updatePanUI(displayValue); } else if (label) { label.textContent = labelFormatter ? labelFormatter(displayValue) : displayValue + suffix; } if (slider && slider.value != storedValue) slider.value = storedValue; if (number && number.value != displayValue) number.value = displayValue; } catch(err){ console.error(`Error in syncAndStoreParam for ${trackParamKey}:`, err); } }; if (slider) { slider.addEventListener("input", (e) => updateState(e.target.value)); } if (number) { number.addEventListener("input", (e) => updateState(e.target.value)); number.addEventListener("change", (e) => updateState(e.target.value)); } }
      updatePitchControlsState() { const waveformSelect = document.getElementById('waveform'); if (!waveformSelect) return; const selectedWaveform = waveformSelect.value; const disablePitchControls = (selectedWaveform === 'noise' || selectedWaveform === 'random'); const pitchGroup = document.getElementById('pitch-envelope-group'); const oscLfoGroup = document.getElementById('osc-lfo-subgroup'); const punchControl = document.getElementById('punch-slider-container'); const setSliderDisabled = (containerSelector, isDisabled) => { const container = document.querySelector(containerSelector); if (!container) return; container.classList.toggle('disabled-control', isDisabled); container.querySelectorAll('input, select').forEach(el => el.disabled = isDisabled); }; document.querySelectorAll('#oscillator-group .slider-container[data-pitch-control]').forEach(container => { const inputs = container.querySelectorAll('input, select'); inputs.forEach(el => el.disabled = disablePitchControls); container.classList.toggle('disabled-control', disablePitchControls); }); if (pitchGroup) { pitchGroup.classList.toggle('disabled-group', disablePitchControls); pitchGroup.querySelectorAll('input, select').forEach(el => el.disabled = disablePitchControls); } if (oscLfoGroup) { oscLfoGroup.classList.toggle('disabled-control', disablePitchControls); oscLfoGroup.querySelectorAll('input, select').forEach(el => el.disabled = disablePitchControls); } if(punchControl) { punchControl.classList.toggle('disabled-control', selectedWaveform === 'noise'); punchControl.querySelectorAll('input').forEach(el => el.disabled = selectedWaveform === 'noise'); } }

      // --- Sequencer UI & Scheduling ---
      initSequencerUI() { const gridContainer = document.getElementById("sequencerGrid"); if (!gridContainer) { console.error("Sequencer grid container not found!"); return; } gridContainer.innerHTML = ''; if (!this.tracks || this.tracks.length !== this.numTracks) { console.error("Track data is invalid or missing for sequencer UI."); return; } try { for(let trackIdx = 0; trackIdx < this.numTracks; trackIdx++) { const trackData = this.tracks[trackIdx]; if (!trackData || !trackData.steps || trackData.steps.length !== 32) { console.warn(`Invalid step data for track ${trackIdx}, skipping UI.`); continue; } const trackLabel = document.createElement('div'); trackLabel.classList.add('track-label'); trackLabel.textContent = `T${trackIdx + 1}`; trackLabel.style.gridRow = `${trackIdx + 1} / ${trackIdx + 2}`; gridContainer.appendChild(trackLabel); for (let stepIdx = 0; stepIdx < 32; stepIdx++) { const stepData = trackData.steps[stepIdx]; if (!stepData) { console.warn(`Missing step data at T${trackIdx+1}, S${stepIdx+1}`); continue; } const stepDiv = document.createElement("div"); stepDiv.classList.add("step"); stepDiv.dataset.trackIndex = trackIdx; stepDiv.dataset.stepIndex = stepIdx; stepDiv.style.gridColumn = `${stepIdx + 2} / ${stepIdx + 3}`; stepDiv.style.gridRow = `${trackIdx + 1} / ${trackIdx + 2}`; const stepNumSpan = document.createElement("span"); stepNumSpan.classList.add("step-top"); stepNumSpan.textContent = stepIdx + 1; stepDiv.appendChild(stepNumSpan); const bottomDiv = document.createElement("div"); bottomDiv.classList.add("step-bottom"); const velocitySpan = document.createElement("span"); velocitySpan.classList.add("velocity-value"); velocitySpan.textContent = stepData.velocity; bottomDiv.appendChild(velocitySpan); const offsetSpan = document.createElement("span"); offsetSpan.classList.add("pitch-offset-value"); offsetSpan.textContent = (stepData.pitchOffset >= 0 ? '+' : '') + stepData.pitchOffset; bottomDiv.appendChild(offsetSpan); stepDiv.appendChild(bottomDiv); stepDiv.classList.toggle("active", stepData.active); stepDiv.addEventListener("click", (e) => { e.preventDefault(); if (e.button !== 0) return; try { const currentTrack = this.tracks[trackIdx]; const currentStep = currentTrack.steps[stepIdx]; currentStep.active = !currentStep.active; stepDiv.classList.toggle("active", currentStep.active); } catch(err){ console.error("Error in step click:", err); } }); stepDiv.addEventListener("contextmenu", (e) => { e.preventDefault(); try { const currentTrack = this.tracks[trackIdx]; const currentStep = currentTrack.steps[stepIdx]; currentStep.active = false; currentStep.velocity = 100; currentStep.pitchOffset = 0; stepDiv.classList.remove("active"); velocitySpan.textContent = currentStep.velocity; offsetSpan.textContent = '+0'; } catch(err){ console.error("Error in step contextmenu:", err); } }); stepDiv.addEventListener('mousedown', (ev) => { if (ev.button === 0) { let isDragging = true; let startY = ev.clientY; let dragMode = ev.shiftKey ? 'pitchOffset' : 'velocity'; let startValue = 0; try { startValue = (dragMode === 'velocity') ? this.tracks[trackIdx].steps[stepIdx].velocity : this.tracks[trackIdx].steps[stepIdx].pitchOffset; } catch (err) { console.error("Error getting start value for drag:", err); isDragging = false; } if(!isDragging) return; stepDiv.style.cursor = 'ns-resize'; document.body.style.cursor = 'ns-resize'; const handleMouseMove = (moveEv) => { if (!isDragging) return; try { const deltaY = startY - moveEv.clientY; const currentStep = this.tracks[trackIdx].steps[stepIdx]; let newValue; if (dragMode === 'velocity') { newValue = startValue + deltaY; newValue = Math.max(0, Math.min(127, Math.round(newValue))); if (currentStep.velocity !== newValue) { currentStep.velocity = newValue; velocitySpan.textContent = newValue; } } else { newValue = startValue + Math.round(deltaY / 2); newValue = Math.max(-48, Math.min(48, newValue)); if (currentStep.pitchOffset !== newValue) { currentStep.pitchOffset = newValue; offsetSpan.textContent = (newValue >= 0 ? '+' : '') + newValue; } } } catch (err) { console.error("Error in drag mousemove:", err); isDragging = false; } }; const handleMouseUp = () => { if (isDragging) { isDragging = false; stepDiv.style.cursor = 'pointer'; document.body.style.cursor = 'default'; window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); } }; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); } }); gridContainer.appendChild(stepDiv); } } console.log("Sequencer UI Initialized Successfully."); } catch (error) { console.error("Error building sequencer grid UI:", error); gridContainer.innerHTML = '<p style="color: red;">Error loading sequencer UI. Check console.</p>'; } this.updateSequenceLengthUI(this.sequenceLength); }
      updateSequenceLengthUI(newLen) { if (isNaN(newLen) || newLen < 1 || newLen > 32) return; this.sequenceLength = newLen; document.querySelectorAll('.step').forEach(stepDiv => { const stepIdx = parseInt(stepDiv.dataset.stepIndex); const trackIdx = parseInt(stepDiv.dataset.trackIndex); if (isNaN(trackIdx) || isNaN(stepIdx) || !this.tracks[trackIdx]?.steps[stepIdx]) return; const stepData = this.tracks[trackIdx].steps[stepIdx]; if (stepIdx < this.sequenceLength) { stepDiv.classList.remove("disabled"); } else { stepDiv.classList.add("disabled"); if(stepData.active) { stepData.active = false; stepDiv.classList.remove("active"); } } }); }
      nextNote() { const secondsPerBeat = 60.0 / this.tempo; this.nextNoteTime += 0.25 * secondsPerBeat; this.current16thNote++; if (this.current16thNote >= this.sequenceLength) { this.current16thNote = 0; } }
      scheduleNote(beatNumber, time) { this.notesInQueue.push({ note: beatNumber, time: time }); const stepElements = document.querySelectorAll(`.step[data-step-index="${beatNumber}"]`); try { let anyTrackSoloed = this.tracks.some(t => t.isSoloed); stepElements.forEach(stepDiv => { if (!stepDiv.classList.contains('disabled')) { const trackIdx = parseInt(stepDiv.dataset.trackIndex); const track = this.tracks[trackIdx]; const stepData = track?.steps[beatNumber]; if (stepData?.active) { let shouldPlay = false; if (anyTrackSoloed) { if (track.isSoloed) { shouldPlay = true; } } else { if (!track.isMuted) { shouldPlay = true; } } if (shouldPlay) { this.playTrackNote(trackIdx, stepData.velocity, stepData.pitchOffset || 0, time); } } } }); } catch(err) { console.error(`Error scheduling notes for beat ${beatNumber} at time ${time}:`, err); } }
      schedulerTick() { if (!this.isPlayingSeq) return; while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) { const visualTimeOffset = 0.02; setTimeout(() => { if (!this.isPlayingSeq) return; const currentVisualStep = this.current16thNote; const prevVisualStep = (currentVisualStep - 1 + this.sequenceLength) % this.sequenceLength; document.querySelectorAll(`.step[data-step-index="${prevVisualStep}"]`).forEach(el => el.classList.remove('playing')); document.querySelectorAll(`.step[data-step-index="${currentVisualStep}"]`).forEach(el => { if (!el.classList.contains('disabled')) { el.classList.add('playing'); } }); }, (this.nextNoteTime - this.audioContext.currentTime - visualTimeOffset) * 1000); this.scheduleNote(this.current16thNote, this.nextNoteTime); this.nextNote(); } this.schedulerInterval = setTimeout(() => this.schedulerTick(), 25); }
      playSequencer() { if (this.isPlayingSeq) { console.log("Sequencer already playing."); return; } if (this.audioContext.state === "suspended") { this.audioContext.resume().then(() => { console.log("AudioContext resumed on play attempt."); this.startScheduler(); }).catch(e => console.error("Resume Error on play:", e)); } else { this.startScheduler(); } }
      startScheduler() { if (this.isPlayingSeq) return; console.log("Starting Sequencer Scheduler..."); this.isPlayingSeq = true; this.current16thNote = 0; this.nextNoteTime = this.audioContext.currentTime + 0.05; this.notesInQueue = []; this.schedulerTick(); console.log("Sequencer scheduler started."); }
      stopSequencer() { if (!this.isPlayingSeq && !this.schedulerInterval) { console.log("Sequencer already stopped."); return; } console.log("Stopping Sequencer..."); this.isPlayingSeq = false; if (this.schedulerInterval) { clearTimeout(this.schedulerInterval); this.schedulerInterval = null; } document.querySelectorAll('.step.playing').forEach(el => el.classList.remove('playing')); this.notesInQueue = []; console.log("Sequencer stopped."); }
      randomizeSelectedTrackSequence() { if (this.selectedTrackIndex < 0 || this.selectedTrackIndex >= this.numTracks) return; const trackIdx = this.selectedTrackIndex; try { for (let i = 0; i < 32; i++) { if (!this.tracks[trackIdx]?.steps[i]) continue; const stepActive = Math.random() < 0.35; this.tracks[trackIdx].steps[i].active = stepActive; this.tracks[trackIdx].steps[i].velocity = 50 + Math.floor(Math.random() * 78); const stepDiv = document.querySelector(`.step[data-track-index="${trackIdx}"][data-step-index="${i}"]`); if (stepDiv) { stepDiv.classList.toggle("active", stepActive); const velSpan = stepDiv.querySelector(".velocity-value"); if (velSpan) velSpan.textContent = this.tracks[trackIdx].steps[i].velocity; } } this.updateSequenceLengthUI(this.sequenceLength); } catch(err){ console.error("Error randomizing steps:", err); } }
      randomizeSelectedTrackTones() { if (this.selectedTrackIndex < 0 || this.selectedTrackIndex >= this.numTracks) return; const trackIdx = this.selectedTrackIndex; console.log(`Randomizing tones for Track ${trackIdx + 1}`); try { for (let i = 0; i < 32; i++) { if (!this.tracks[trackIdx]?.steps[i]) continue; this.tracks[trackIdx].steps[i].pitchOffset = Math.floor(Math.random() * 97) - 48; const stepDiv = document.querySelector(`.step[data-track-index="${trackIdx}"][data-step-index="${i}"]`); if (stepDiv) { const offsetSpan = stepDiv.querySelector(".pitch-offset-value"); if (offsetSpan) { const offset = this.tracks[trackIdx].steps[i].pitchOffset; offsetSpan.textContent = (offset >= 0 ? '+' : '') + offset; } } } } catch(err){ console.error("Error randomizing tones:", err); } }
      clearSelectedTrackSequence() { if (this.selectedTrackIndex < 0 || this.selectedTrackIndex >= this.numTracks) return; try { this.clearTrackSequence(this.selectedTrackIndex); } catch(err){ console.error("Error clearing track steps:", err); } }
      clearAllTrackSequences() { try { for (let trackIdx = 0; trackIdx < this.numTracks; trackIdx++) { this.clearTrackSequence(trackIdx); } } catch(err){ console.error("Error clearing all steps:", err); } }
      clearTrackSequence(trackIdx) { if (trackIdx < 0 || trackIdx >= this.numTracks) return; for (let i = 0; i < 32; i++) { if (!this.tracks[trackIdx]?.steps[i]) continue; this.tracks[trackIdx].steps[i].active = false; this.tracks[trackIdx].steps[i].velocity = 100; this.tracks[trackIdx].steps[i].pitchOffset = 0; const stepDiv = document.querySelector(`.step[data-track-index="${trackIdx}"][data-step-index="${i}"]`); if (stepDiv) { stepDiv.classList.remove("active", "playing"); const velocitySpan = stepDiv.querySelector(".velocity-value"); if (velocitySpan) velocitySpan.textContent = "100"; const offsetSpan = stepDiv.querySelector(".pitch-offset-value"); if (offsetSpan) offsetSpan.textContent = "+0"; } } }


      // --- Unified Audio Chain Creation ---
      createAudioChainForTrack(context, trackIndex, velocity, startTime = context.currentTime, stepPitchOffset = 0, targetNodes = null) {
          if (trackIndex < 0 || trackIndex >= this.numTracks || !this.tracks[trackIndex]) { return { source: null, stopTime: startTime, allNodes: [], isBufferSource: false }; }
          const params = this.tracks[trackIndex].params; const now = startTime; const waveform = params.waveform || 'sine'; const allNodes = [];
          const reverbTarget = targetNodes ? targetNodes.reverb : this.reverbPreDelay; const delayTarget = targetNodes ? targetNodes.delay : this.delayNode; const flangerTarget = targetNodes ? targetNodes.flanger : this.flangerInput; const compressorTarget = targetNodes ? targetNodes.compressor : this.masterCompressor;
          if (!reverbTarget || !delayTarget || !flangerTarget || !compressorTarget) { console.error(`Missing target node(s) for track ${trackIndex}`); return { source: null, stopTime: startTime, allNodes: [], isBufferSource: false }; }
          try {
              const hasOscLFO = (params.oscLfoAmount || 0) > 0 && waveform !== 'noise' && waveform !== 'random'; const ampAttack=Math.max(0.001,(params.ampAttack||1)/1000); const ampDecay=Math.max(0.001,(params.ampDecay||100)/1000); const ampSustain=Math.max(0,Math.min(1,(params.ampSustain||0)/100)); const ampRelease=Math.max(0.001,(params.ampRelease||100)/1000); const filterCutoff=Math.max(20,Math.min(context.sampleRate/2,params.cutoff||5000)); const filterResonance=Math.max(0,params.resonance||1); const filterEnvAmount=Math.max(0,Math.min(1,(params.filterEnv||0)/100)); const hpCutoff=Math.max(20,Math.min(context.sampleRate/2,params.hpCutoff||20)); const hpResonance=Math.max(0,params.hpResonance||0); const hpFilterEnv=Math.max(0,Math.min(1,(params.hpFilterEnv||0)/100)); const pitchEnvAmount=Math.max(0,Math.min(1,(params.pitchEnvAmount||0)/100)); const pitchSpeed=params.pitchSpeed||0; const pitchAttack=Math.max(0.001,(params.pitchAttack||1)/1000); const pitchDecay=Math.max(0.001,(params.pitchDecay||100)/1000); const pitchSustain=Math.max(0,Math.min(1,(params.pitchSustain||0)/100)); const pitchRelease=Math.max(0.001,(params.pitchRelease||100)/1000);
              let baseFreq = 0; if (waveform !== 'noise' && waveform !== 'random') { const octaveFreq = this.octaveFreqs[params.octave || 4] || 32.70; const pitchSliderVal = params.pitch !== undefined ? params.pitch : 500; if (pitchSliderVal === 0) { baseFreq = 0; } else { baseFreq = octaveFreq + pitchSliderVal; baseFreq = Math.max(0, Math.min(20000, baseFreq)); } if (stepPitchOffset !== 0 && baseFreq > 0) { baseFreq = baseFreq * Math.pow(2, stepPitchOffset / 12.0); baseFreq = Math.max(0, Math.min(20000, baseFreq)); } }
              const punchAmount = (params.punch || 0) / 100.0; const trackDistortion = Math.max(0, params.distortion || 0); const trackVolume = Math.max(0, Math.min(1, (params.trackVolume || 100) / 100)); const velocityGainVal = Math.max(0, Math.min(1, velocity / 127.0)); const panValue = (params.pan || 0) / 100.0; const reverbSendLevel = (params.reverbSend || 0) / 100.0; const delaySendLevel = (params.delaySend || 0) / 100.0; const flangerSendLevel = (params.flangerSend || 0) / 100.0;

              let source; let osc = null; let isBufferSource = false;
              if (waveform === "noise") { source = context.createBufferSource(); source.buffer = this.noiseBuffer; if (context instanceof AudioContext) { source.loop = true; } isBufferSource = true; } else if (waveform === "random") { const randomFreq = 40 + Math.random() * 4000; osc = context.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(randomFreq, now); source = osc; } else { osc = context.createOscillator(); osc.type = waveform; osc.frequency.setValueAtTime(baseFreq, now); source = osc; } allNodes.push(source);
              const punchGain = context.createGain(); punchGain.gain.value = 1.0; allNodes.push(punchGain);
              let oscLfoSource = null; let oscLfoModGain = null; if (hasOscLFO && osc) { oscLfoSource = context.createOscillator(); oscLfoSource.type = params.oscLfoShape || 'sine'; oscLfoSource.frequency.value = Math.max(0.01, params.oscLfoRate || 5.0); oscLfoModGain = context.createGain(); const lfoDepthHz = (params.oscLfoAmount / 100.0) * Math.min(baseFreq * 0.5, 50); oscLfoModGain.gain.value = lfoDepthHz > 0 ? lfoDepthHz : 0.01; oscLfoSource.connect(oscLfoModGain); oscLfoModGain.connect(osc.frequency); allNodes.push(oscLfoSource, oscLfoModGain); }
              const filterLP=context.createBiquadFilter(); filterLP.type="lowpass"; filterLP.frequency.value = filterCutoff; filterLP.Q.value = filterResonance; allNodes.push(filterLP); const filterHP=context.createBiquadFilter(); filterHP.type="highpass"; filterHP.frequency.value = hpCutoff; filterHP.Q.value = hpResonance; allNodes.push(filterHP);
              const sendTapGain = context.createGain(); sendTapGain.gain.value = 1.0; allNodes.push(sendTapGain); const reverbSendGain = context.createGain(); reverbSendGain.gain.value = reverbSendLevel; allNodes.push(reverbSendGain); const delaySendGain = context.createGain(); delaySendGain.gain.value = delaySendLevel; allNodes.push(delaySendGain); const flangerSendGain = context.createGain(); flangerSendGain.gain.value = flangerSendLevel; allNodes.push(flangerSendGain);
              const distortionNode=context.createWaveShaper(); distortionNode.curve=this.makeDistortionCurve(trackDistortion); distortionNode.oversample="4x"; allNodes.push(distortionNode); const makeupGain = context.createGain(); makeupGain.gain.value = 1.0 + (trackDistortion / 60.0); allNodes.push(makeupGain); const trackVolVelGain=context.createGain(); trackVolVelGain.gain.value = trackVolume*velocityGainVal; allNodes.push(trackVolVelGain); const panNode = context.createStereoPanner(); panNode.pan.setValueAtTime(panValue, now); allNodes.push(panNode); const ampEnvGainNode=context.createGain(); ampEnvGainNode.gain.value = 0; allNodes.push(ampEnvGainNode);

              source.connect(punchGain).connect(filterLP).connect(filterHP).connect(sendTapGain);
              sendTapGain.connect(reverbSendGain).connect(reverbTarget); sendTapGain.connect(delaySendGain).connect(delayTarget); sendTapGain.connect(flangerSendGain).connect(flangerTarget);
              sendTapGain.connect(distortionNode).connect(makeupGain).connect(trackVolVelGain).connect(ampEnvGainNode).connect(panNode).connect(compressorTarget);

              if (punchAmount > 0.01 && waveform !== 'noise') { const punchAttackTime = 0.001; const punchDecayTime = 0.02 + (punchAmount * 0.08); const punchLevel = 1.0 + punchAmount * 3.0; punchGain.gain.linearRampToValueAtTime(punchLevel, now + punchAttackTime); punchGain.gain.linearRampToValueAtTime(1.0, now + punchAttackTime + punchDecayTime); }
              if (oscLfoSource) { oscLfoSource.start(now); }
              ampEnvGainNode.gain.setValueAtTime(0, now); ampEnvGainNode.gain.linearRampToValueAtTime(1, now + ampAttack); ampEnvGainNode.gain.linearRampToValueAtTime(ampSustain, now + ampAttack + ampDecay); ampEnvGainNode.gain.setTargetAtTime(0.0001, now + ampAttack + ampDecay, ampRelease / 4);
              const lpEnvMax=filterCutoff+filterEnvAmount*(context.sampleRate/2.1-filterCutoff); const lpEnvSustainVal=filterCutoff+(lpEnvMax-filterCutoff)*ampSustain; filterLP.frequency.setValueAtTime(filterCutoff, now); filterLP.frequency.linearRampToValueAtTime(lpEnvMax, now + ampAttack); filterLP.frequency.linearRampToValueAtTime(lpEnvSustainVal, now + ampAttack + ampDecay); filterLP.frequency.setTargetAtTime(filterCutoff, now + ampAttack + ampDecay, ampRelease / 4);
              const hpEnvMax=hpCutoff+hpFilterEnv*(context.sampleRate/2.1-hpCutoff); const hpEnvSustainVal=hpCutoff+(hpEnvMax-hpCutoff)*ampSustain; filterHP.frequency.setValueAtTime(hpCutoff, now); filterHP.frequency.linearRampToValueAtTime(hpEnvMax, now + ampAttack); filterHP.frequency.linearRampToValueAtTime(hpEnvSustainVal, now + ampAttack + ampDecay); filterHP.frequency.setTargetAtTime(hpCutoff, now + ampAttack + ampDecay, ampRelease / 4);
              if (osc && pitchEnvAmount > 0.001 && waveform !== 'noise' && waveform !== 'random') { let speedFactor = Math.pow(0.5, pitchSpeed / 50.0); speedFactor = Math.max(0.01, Math.min(10.0, speedFactor)); const effectivePitchAttack = Math.max(0.001, pitchAttack * speedFactor); const effectivePitchDecay = Math.max(0.001, pitchDecay * speedFactor); const effectivePitchRelease = Math.max(0.001, pitchRelease * speedFactor); const pitchRange = baseFreq > 0 ? baseFreq * 4 * pitchEnvAmount : 0; const pitchAttackVal = baseFreq + pitchRange; const pitchSustainVal = baseFreq + pitchRange * pitchSustain; osc.frequency.cancelScheduledValues(now); osc.frequency.setValueAtTime(baseFreq, now); osc.frequency.linearRampToValueAtTime(pitchAttackVal, now + effectivePitchAttack); osc.frequency.linearRampToValueAtTime(pitchSustainVal, now + effectivePitchAttack + effectivePitchDecay); osc.frequency.setTargetAtTime(baseFreq, now + effectivePitchAttack + effectivePitchDecay, effectivePitchRelease / 4); }
              else if (osc && waveform !== 'noise' && waveform !== 'random'){ osc.frequency.cancelScheduledValues(now); osc.frequency.setValueAtTime(baseFreq, now); }

              const stopTime = now + ampAttack + ampDecay + ampRelease + 0.3;
              if (oscLfoSource) { try { oscLfoSource.stop(stopTime); } catch (e) {} }
              return { source, stopTime, allNodes, isBufferSource };
          } catch (error) { console.error(`Error creating audio chain for track ${trackIndex} at time ${startTime}:`, error); allNodes.forEach(node => { try { node.disconnect(); } catch(e){} }); return { source: null, stopTime: startTime, allNodes: [], isBufferSource: false }; }
      }

      // --- playTrackNote ---
      playTrackNote(trackIndex, velocity = 127, stepPitchOffset = 0, scheduledTime = this.audioContext.currentTime) {
         if (this.audioContext.state === 'suspended') { console.warn("AudioContext suspended. Cannot play note."); return; } const now = scheduledTime; let source = null; let stopTime = now + 0.1; let allNodes = []; let isBufferSource = false;
         try {
             const chain = this.createAudioChainForTrack(this.audioContext, trackIndex, velocity, now, stepPitchOffset, null); source = chain.source; stopTime = chain.stopTime; allNodes = chain.allNodes; isBufferSource = chain.isBufferSource;
             if (source) {
                 source.start(now); try { source.stop(stopTime); } catch (e) { console.warn(`Error scheduling source stop for T${trackIndex+1}:`, e); }
                 const cleanupNodes = () => { if (this.audioContext.state === 'running') { allNodes.forEach((node) => { try { node.disconnect(); } catch (e) { /* Ignore */ } }); } };
                 if (isBufferSource && source instanceof AudioBufferSourceNode) { source.onended = cleanupNodes; } else { const delayUntilStop = Math.max(0, stopTime - this.audioContext.currentTime); const disconnectDelay = Math.max(30, (delayUntilStop + 0.1) * 1000); setTimeout(cleanupNodes, disconnectDelay); }
             } else { console.warn(`Failed to create audio chain for track ${trackIndex + 1} scheduled at ${now.toFixed(3)}.`); }
         } catch (error) { console.error(`Error playing track ${trackIndex + 1} scheduled at ${now.toFixed(3)}:`, error); allNodes.forEach(node => { try { node.disconnect(); } catch(e){} }); }
      }

      // --- generateTrackWAV, exportSequence ---
      generateTrackWAV(trackIndex) {
          if (trackIndex < 0 || trackIndex >= this.numTracks || !this.tracks[trackIndex]) { alert(`Invalid track index ${trackIndex}`); return; } console.log(`Generating WAV for Track ${trackIndex + 1}...`); const offlineSampleRate = this.audioContext.sampleRate; const params = this.tracks[trackIndex].params; const baseDuration = (params.ampAttack + params.ampDecay + params.ampRelease) / 1000; const duration = baseDuration + this.MAX_DELAY_TIME + this.MAX_FLANGER_DELAY + 2.5; const offlineContext = new OfflineAudioContext(2, Math.ceil(duration * offlineSampleRate), offlineSampleRate);
          const masterCompOffline = offlineContext.createDynamicsCompressor(); masterCompOffline.threshold.value = this.masterCompressor.threshold.value; masterCompOffline.knee.value = this.masterCompressor.knee.value; masterCompOffline.ratio.value = this.masterCompressor.ratio.value; masterCompOffline.attack.value = this.masterCompressor.attack.value; masterCompOffline.release.value = this.masterCompressor.release.value;
          const masterGainOffline = offlineContext.createGain(); masterGainOffline.gain.value = this.masterGain.gain.value;
          const reverbPreDelayOffline = offlineContext.createDelay(this.MAX_REVERB_PREDELAY); reverbPreDelayOffline.delayTime.value = this.reverbPreDelay.delayTime.value; const reverbNodeOffline = offlineContext.createConvolver(); if (this.reverbNode.buffer) reverbNodeOffline.buffer = this.reverbNode.buffer; else console.warn("Offline Reverb: Missing IR buffer!"); const reverbWetGainOffline = offlineContext.createGain(); reverbWetGainOffline.gain.value = this.reverbWetGain.gain.value; const reverbToneOffline = offlineContext.createBiquadFilter(); reverbToneOffline.type = this.reverbToneFilter.type; reverbToneOffline.frequency.value = this.reverbToneFilter.frequency.value;
          const delayNodeOffline = offlineContext.createDelay(this.MAX_DELAY_TIME); delayNodeOffline.delayTime.value = this.delayNode.delayTime.value; const delayFbGainOffline = offlineContext.createGain(); delayFbGainOffline.gain.value = this.delayFeedbackGain.gain.value; const delayWetGainOffline = offlineContext.createGain(); delayWetGainOffline.gain.value = this.delayWetGain.gain.value;
          const flangerInputOffline = offlineContext.createGain(); const flangerDelayOffline = offlineContext.createDelay(this.MAX_FLANGER_DELAY); flangerDelayOffline.delayTime.value = this.flangerDelay.delayTime.value; const flangerLFOOffline = offlineContext.createOscillator(); flangerLFOOffline.type = this.flangerLFO.type; flangerLFOOffline.frequency.value = this.flangerLFO.frequency.value; const flangerLFODepthOffline = offlineContext.createGain(); flangerLFODepthOffline.gain.value = this.flangerLFODepth.gain.value; const flangerFeedbackOffline = offlineContext.createGain(); flangerFeedbackOffline.gain.value = this.flangerFeedback.gain.value; const flangerWetGainOffline = offlineContext.createGain(); flangerWetGainOffline.gain.value = this.flangerWetGain.gain.value;
          reverbPreDelayOffline.connect(reverbNodeOffline).connect(reverbWetGainOffline).connect(reverbToneOffline).connect(masterCompOffline); delayNodeOffline.connect(delayFbGainOffline); delayFbGainOffline.connect(delayNodeOffline); delayNodeOffline.connect(delayWetGainOffline).connect(masterCompOffline); flangerInputOffline.connect(flangerDelayOffline); flangerLFOOffline.connect(flangerLFODepthOffline); flangerLFODepthOffline.connect(flangerDelayOffline.delayTime); flangerDelayOffline.connect(flangerFeedbackOffline); flangerFeedbackOffline.connect(flangerDelayOffline); flangerDelayOffline.connect(flangerWetGainOffline); flangerWetGainOffline.connect(masterCompOffline); masterCompOffline.connect(masterGainOffline).connect(offlineContext.destination);
          flangerLFOOffline.start(0);
          const offlineTargets = { reverb: reverbPreDelayOffline, delay: delayNodeOffline, flanger: flangerInputOffline, compressor: masterCompOffline };
          const { source, stopTime, allNodes, isBufferSource } = this.createAudioChainForTrack(offlineContext, trackIndex, 127, 0, 0, offlineTargets);
          if (source) {
              source.start(0); try { source.stop(stopTime); const oscLfoNode = allNodes.find(n => n instanceof OscillatorNode && n !== source && n !== flangerLFOOffline); if (oscLfoNode) oscLfoNode.stop(stopTime); } catch (e) { console.warn("Error stopping offline source/LFO:", e); }
              offlineContext.startRendering().then((renderedBuffer) => { console.log("Offline rendering complete."); const normalize = document.getElementById("normalizeCheckbox").checked; if (normalize) { this.normalizeBuffer(renderedBuffer); } const wavBlob = this.bufferToWave(renderedBuffer, 24); this.downloadBlob(wavBlob, `track_${trackIndex + 1}_sound.wav`); }).catch(err => { console.error("Offline rendering failed:", err); alert("Failed to generate WAV."); });
          } else { console.error("Failed WAV chain creation for track " + trackIndex); alert("Failed WAV chain creation."); }
      }
      exportSequence() {
          this.stopSequencer(); console.log("Exporting Sequence..."); const offlineSampleRate = this.audioContext.sampleRate; const secondsPerBeat = 60.0 / this.tempo; const stepDuration = 0.25 * secondsPerBeat; let longestNoteDuration = 0; for(let t=0; t<this.numTracks; t++){ const p = this.tracks[t].params; const dur = (p.ampAttack + p.ampDecay + p.ampRelease) / 1000; longestNoteDuration = Math.max(longestNoteDuration, dur); } const totalDuration = (stepDuration * (this.sequenceLength - 1)) + longestNoteDuration + this.MAX_DELAY_TIME + this.MAX_FLANGER_DELAY + 2.5; const offlineContext = new OfflineAudioContext(2, Math.ceil(totalDuration * offlineSampleRate), offlineSampleRate);
          const masterCompOffline = offlineContext.createDynamicsCompressor(); masterCompOffline.threshold.value = this.masterCompressor.threshold.value; masterCompOffline.knee.value = this.masterCompressor.knee.value; masterCompOffline.ratio.value = this.masterCompressor.ratio.value; masterCompOffline.attack.value = this.masterCompressor.attack.value; masterCompOffline.release.value = this.masterCompressor.release.value; const masterGainOffline = offlineContext.createGain(); masterGainOffline.gain.value = this.masterGain.gain.value; const reverbPreDelayOffline = offlineContext.createDelay(this.MAX_REVERB_PREDELAY); reverbPreDelayOffline.delayTime.value = this.reverbPreDelay.delayTime.value; const reverbNodeOffline = offlineContext.createConvolver(); if (this.reverbNode.buffer) reverbNodeOffline.buffer = this.reverbNode.buffer; else console.warn("Offline Reverb Seq: Missing IR buffer!"); const reverbWetGainOffline = offlineContext.createGain(); reverbWetGainOffline.gain.value = this.reverbWetGain.gain.value; const reverbToneOffline = offlineContext.createBiquadFilter(); reverbToneOffline.type = this.reverbToneFilter.type; reverbToneOffline.frequency.value = this.reverbToneFilter.frequency.value; const delayNodeOffline = offlineContext.createDelay(this.MAX_DELAY_TIME); delayNodeOffline.delayTime.value = this.delayNode.delayTime.value; const delayFbGainOffline = offlineContext.createGain(); delayFbGainOffline.gain.value = this.delayFeedbackGain.gain.value; const delayWetGainOffline = offlineContext.createGain(); delayWetGainOffline.gain.value = this.delayWetGain.gain.value; const flangerInputOffline = offlineContext.createGain(); const flangerDelayOffline = offlineContext.createDelay(this.MAX_FLANGER_DELAY); flangerDelayOffline.delayTime.value = this.flangerDelay.delayTime.value; const flangerLFOOffline = offlineContext.createOscillator(); flangerLFOOffline.type = this.flangerLFO.type; flangerLFOOffline.frequency.value = this.flangerLFO.frequency.value; const flangerLFODepthOffline = offlineContext.createGain(); flangerLFODepthOffline.gain.value = this.flangerLFODepth.gain.value; const flangerFeedbackOffline = offlineContext.createGain(); flangerFeedbackOffline.gain.value = this.flangerFeedback.gain.value; const flangerWetGainOffline = offlineContext.createGain(); flangerWetGainOffline.gain.value = this.flangerWetGain.gain.value;
          reverbPreDelayOffline.connect(reverbNodeOffline).connect(reverbWetGainOffline).connect(reverbToneOffline).connect(masterCompOffline); delayNodeOffline.connect(delayFbGainOffline); delayFbGainOffline.connect(delayNodeOffline); delayNodeOffline.connect(delayWetGainOffline).connect(masterCompOffline); flangerInputOffline.connect(flangerDelayOffline); flangerLFOOffline.connect(flangerLFODepthOffline); flangerLFODepthOffline.connect(flangerDelayOffline.delayTime); flangerDelayOffline.connect(flangerFeedbackOffline); flangerFeedbackOffline.connect(flangerDelayOffline); flangerDelayOffline.connect(flangerWetGainOffline); flangerWetGainOffline.connect(masterCompOffline); masterCompOffline.connect(masterGainOffline).connect(offlineContext.destination);
          flangerLFOOffline.start(0);
          const offlineTargets = { reverb: reverbPreDelayOffline, delay: delayNodeOffline, flanger: flangerInputOffline, compressor: masterCompOffline };
          let maxStopTime = 0; const allScheduledTrackNodes = [];
          for (let stepIdx = 0; stepIdx < this.sequenceLength; stepIdx++) {
              const currentTime = stepIdx * stepDuration;
              for (let trackIdx = 0; trackIdx < this.numTracks; trackIdx++) {
                  let anySoloed = this.tracks.some(t => t.isSoloed); let shouldRender = false; if(anySoloed){ if(this.tracks[trackIdx].isSoloed) shouldRender = true; } else { if(!this.tracks[trackIdx].isMuted) shouldRender = true; } if(!shouldRender || !this.tracks[trackIdx]?.steps[stepIdx]) continue;
                  const stepData = this.tracks[trackIdx].steps[stepIdx];
                  if (stepData.active) {
                      const { source, stopTime, allNodes, isBufferSource } = this.createAudioChainForTrack( offlineContext, trackIdx, stepData.velocity, currentTime, stepData.pitchOffset || 0, offlineTargets );
                      if (source) {
                          source.start(currentTime); try { source.stop(stopTime); } catch (e) {console.warn(`Offline stop error T${trackIdx} S${stepIdx}: ${e}`)} maxStopTime = Math.max(maxStopTime, stopTime); allScheduledTrackNodes.push(...allNodes); const oscLfoNode = allNodes.find(n => n instanceof OscillatorNode && n !== source && n !== flangerLFOOffline); if (oscLfoNode) { try { oscLfoNode.stop(stopTime); } catch (e) {} }
                      }
                  }
              }
          }
          console.log(`Rendering sequence: ${this.sequenceLength} steps, Max Stop Time: ${maxStopTime.toFixed(2)}s, Render Duration: ${totalDuration.toFixed(2)}s`);
          offlineContext.startRendering().then((renderedBuffer) => { console.log("Sequence rendering complete."); const normalize = document.getElementById("normalizeCheckbox").checked; if (normalize) { this.normalizeBuffer(renderedBuffer); } const wavBlob = this.bufferToWave(renderedBuffer, 24); this.downloadBlob(wavBlob, "sequence_export.wav"); }).catch(err => { console.error("Sequence rendering failed:", err); alert("Failed to export sequence."); });
      }


      // --- State Management (Updated for Flanger, Save Fix) ---
      gatherStateData() {
           console.log("Gathering state data..."); // Log start
           try {
               const tracksData = this.tracks.map(track => {
                   const params = { ...track.params };
                   // Ensure all expected params exist and sanitize
                   params.pitch = Math.max(0, Math.min(15000, params.pitch || 0));
                   params.pan = Math.max(-100, Math.min(100, params.pan || 0));
                   params.reverbSend = Math.max(0, Math.min(100, params.reverbSend || 0));
                   params.delaySend = Math.max(0, Math.min(100, params.delaySend || 0));
                   params.flangerSend = Math.max(0, Math.min(100, params.flangerSend || 0)); // Ensure flanger send exists
                   params.punch = Math.max(0, Math.min(100, params.punch || 0));
                   // Explicitly delete potentially old params to avoid saving them
                   delete params.chorusSend;
                   delete params.phaserSend;
                   return {
                       params: params,
                       steps: track.steps.map(step => ({ ...step })), // Deep copy steps
                       isMuted: track.isMuted,
                       isSoloed: track.isSoloed
                   };
               });

               const globalSettings = {
                   tempo: this.tempo, sequenceLength: this.sequenceLength, masterVolume: this.masterGain.gain.value * 100, compThreshold: this.masterCompressor.threshold.value, compRatio: this.masterCompressor.ratio.value, scopeZoom: this.scopeZoom, normalizeChecked: document.getElementById('normalizeCheckbox').checked,
                   masterReverbPreDelay: this.reverbPreDelay.delayTime.value * 1000, masterReverbTone: this.reverbToneFilter.frequency.value, masterReverbWet: this.reverbWetGain.gain.value * 100,
                   masterDelayDivision: this.delayDivision, masterDelayFeedback: this.delayFeedbackGain.gain.value * 100, masterDelayWet: this.delayWetGain.gain.value * 100,
                   // Ensure flanger nodes exist before accessing properties
                   masterFlangerRate: this.flangerLFO?.frequency.value || this.DEFAULT_FLANGER_RATE,
                   masterFlangerDepth: (this.flangerLFODepth?.gain.value || (this.DEFAULT_FLANGER_DEPTH_MS / 1000.0)) * 1000, // Convert back to ms
                   masterFlangerDelay: (this.flangerDelay?.delayTime.value || (this.DEFAULT_FLANGER_DELAY_MS / 1000.0)) * 1000, // Convert back to ms
                   masterFlangerFeedback: (this.flangerFeedback?.gain.value || (this.DEFAULT_FLANGER_FEEDBACK / 100.0)) * 100, // Convert back to %
                   masterFlangerWet: (this.flangerWetGain?.gain.value || (this.DEFAULT_FLANGER_WET / 100.0)) * 100, // Convert back to %
               };

               console.log("Global settings gathered:", globalSettings); // Log gathered global settings

               const stateData = {
                   saveFileVersion: this.saveFileVersion,
                   globalSettings: globalSettings,
                   tracks: tracksData
               };
               console.log("Complete state data object created."); // Log before return
               return stateData;

           } catch (error) {
               console.error("Error during gatherStateData:", error);
               throw error; // Re-throw to be caught by saveState
           }
       }
      saveState() {
           console.log("Saving state...");
           try {
               const stateData = this.gatherStateData(); // Gather the data first
               console.log("State data gathered successfully for saving.");

               // Attempt to stringify, catch errors specifically here
               let jsonString;
               try {
                   jsonString = JSON.stringify(stateData, null, 2);
                   console.log("JSON stringification successful.");
               } catch (stringifyError) {
                   console.error("FATAL: Error converting state data to JSON:", stringifyError);
                   console.error("State Data Object:", stateData); // Log the object that failed
                   alert(`Failed to serialize state data: ${stringifyError.message}. Check console for details.`);
                   return; // Stop the save process
               }

               const blob = new Blob([jsonString], { type: "application/json" });
               const now = new Date();
               const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
               const filename = `kretz8_flanger_${timestamp}.krtz`; // Updated filename pattern

               this.downloadBlob(blob, filename);
               console.log("State saved successfully to " + filename);

           } catch (error) {
               console.error("Error in saveState function:", error);
               alert(`Failed to save state: ${error.message}`);
           }
       }
      loadState(file) {
          console.log("Loading state:", file.name); const reader = new FileReader();
          reader.onload = (event) => {
              try {
                  const jsonString = event.target.result; const loadedData = JSON.parse(jsonString); if (!loadedData || typeof loadedData !== 'object' || !loadedData.globalSettings || !Array.isArray(loadedData.tracks)) throw new Error("Invalid file format."); const loadedVersion = loadedData.saveFileVersion || 'Unknown'; console.log(`Parsed data. Ver: ${loadedVersion}, Tracks: ${loadedData.tracks.length}`); let versionWarning = ''; if (loadedData.tracks.length !== this.numTracks) { versionWarning = ` Track count mismatch (${loadedData.tracks.length} vs ${this.numTracks}).`; console.warn(versionWarning); }
                  this.stopSequencer(); const global = loadedData.globalSettings; const now = this.audioContext.currentTime;

                  // Load Tempo, SeqLen, MasterVol, Comp, Scope, Normalize, Reverb, Delay (as before)
                  this.tempo = parseInt(global.tempo) || 120; this.updateSliderAndNumber("tempo", "tempoInput", "tempoValue", this.tempo, " BPM");
                  const newLength = parseInt(global.sequenceLength) || 32;
                  const masterVol = parseFloat(global.masterVolume) || this.DEFAULT_MASTER_VOLUME; this.masterGain.gain.setTargetAtTime(masterVol / 100, now, 0.01); this.updateSliderAndNumber("masterVolume", "masterVolumeInput", "masterVolumeValue", masterVol, "%");
                  const compThresh = parseFloat(global.compThreshold) || -24; this.masterCompressor.threshold.setTargetAtTime(compThresh, now, 0.01); this.updateSliderAndNumber("compThreshold", "compThresholdInput", "compThresholdValue", compThresh, " dB");
                  const compRatio = parseFloat(global.compRatio) || 12; this.masterCompressor.ratio.setTargetAtTime(compRatio, now, 0.01); this.updateSliderAndNumber("compRatio", "compRatioInput", "compRatioValue", compRatio, ":1");
                  this.scopeZoom = parseFloat(global.scopeZoom) || 1.0; this.updateSliderAndNumber("scopeZoom", "scopeZoomInput", "scopeZoomLabel", this.scopeZoom.toFixed(1), "x");
                  document.getElementById('normalizeCheckbox').checked = global.normalizeChecked !== undefined ? global.normalizeChecked : true;
                  const reverbPreDelay = parseFloat(global.masterReverbPreDelay) || this.DEFAULT_REVERB_PREDELAY; this.reverbPreDelay.delayTime.setTargetAtTime(reverbPreDelay / 1000.0, now, 0.01); this.updateSliderAndNumber("masterReverbPreDelay", "masterReverbPreDelayInput", "masterReverbPreDelayValue", reverbPreDelay.toFixed(0), " ms");
                  const reverbTone = parseFloat(global.masterReverbTone) || this.DEFAULT_REVERB_TONE; this.reverbToneFilter.frequency.setTargetAtTime(reverbTone, now, 0.01); this.updateSliderAndNumber("masterReverbTone", "masterReverbToneInput", "masterReverbToneValue", reverbTone.toFixed(0), " Hz");
                  const reverbWet = parseFloat(global.masterReverbWet) || this.DEFAULT_REVERB_WET; this.reverbWetGain.gain.setTargetAtTime(reverbWet / 100.0, now, 0.01); this.updateSliderAndNumber("masterReverbWet", "masterReverbWetInput", "masterReverbWetValue", reverbWet.toFixed(0), "%");
                  this.delayDivision = global.masterDelayDivision || this.DEFAULT_DELAY_DIVISION; document.getElementById('masterDelayDivision').value = this.delayDivision; this.updateDelayTimeBasedOnTempo();
                  const delayFb = parseFloat(global.masterDelayFeedback) || this.DEFAULT_DELAY_FEEDBACK; this.delayFeedbackGain.gain.setTargetAtTime(Math.min(this.MAX_DELAY_FEEDBACK, delayFb / 100.0), now, 0.01); this.updateSliderAndNumber("masterDelayFeedback", "masterDelayFeedbackInput", "masterDelayFeedbackValue", delayFb.toFixed(0), "%");
                  const delayWet = parseFloat(global.masterDelayWet) || this.DEFAULT_DELAY_WET; this.delayWetGain.gain.setTargetAtTime(delayWet / 100.0, now, 0.01); this.updateSliderAndNumber("masterDelayWet", "masterDelayWetInput", "masterDelayWetValue", delayWet.toFixed(0), "%");

                  // Load Flanger settings safely
                  const flangerRate = parseFloat(global.masterFlangerRate) || this.DEFAULT_FLANGER_RATE; if(this.flangerLFO) this.flangerLFO.frequency.setTargetAtTime(flangerRate, now, 0.01); this.updateSliderAndNumber("masterFlangerRate", "masterFlangerRateInput", "masterFlangerRateValue", flangerRate.toFixed(2), " Hz");
                  const flangerDepth = parseFloat(global.masterFlangerDepth) || this.DEFAULT_FLANGER_DEPTH_MS; if(this.flangerLFODepth) this.flangerLFODepth.gain.setTargetAtTime(flangerDepth / 1000.0, now, 0.01); this.updateSliderAndNumber("masterFlangerDepth", "masterFlangerDepthInput", "masterFlangerDepthValue", flangerDepth.toFixed(1), " ms");
                  const flangerDelay = parseFloat(global.masterFlangerDelay) || this.DEFAULT_FLANGER_DELAY_MS; if(this.flangerDelay) this.flangerDelay.delayTime.setTargetAtTime(flangerDelay / 1000.0, now, 0.01); this.updateSliderAndNumber("masterFlangerDelay", "masterFlangerDelayInput", "masterFlangerDelayValue", flangerDelay.toFixed(1), " ms");
                  const flangerFb = parseFloat(global.masterFlangerFeedback) || this.DEFAULT_FLANGER_FEEDBACK; if(this.flangerFeedback) this.flangerFeedback.gain.setTargetAtTime(flangerFb / 100.0, now, 0.01); this.updateSliderAndNumber("masterFlangerFeedback", "masterFlangerFeedbackInput", "masterFlangerFeedbackValue", flangerFb.toFixed(0), " %");
                  const flangerWet = parseFloat(global.masterFlangerWet) || this.DEFAULT_FLANGER_WET; if(this.flangerWetGain) this.flangerWetGain.gain.setTargetAtTime(flangerWet / 100.0, now, 0.01); this.updateSliderAndNumber("masterFlangerWet", "masterFlangerWetInput", "masterFlangerWetValue", flangerWet.toFixed(0), "%");

                  const newTracks = [];
                  for (let i = 0; i < this.numTracks; i++) {
                       const loadedTrackData = loadedData.tracks[i];
                       if (loadedTrackData && loadedTrackData.params && loadedTrackData.steps) {
                           const defaultParams = this.getDefaultTrackParams(i); const mergedParams = { ...defaultParams, ...loadedTrackData.params };
                           mergedParams.pitch = Math.max(0, Math.min(15000, mergedParams.pitch || 0)); mergedParams.pan = Math.max(-100, Math.min(100, mergedParams.pan || 0)); mergedParams.reverbSend = Math.max(0, Math.min(100, mergedParams.reverbSend || 0)); mergedParams.delaySend = Math.max(0, Math.min(100, mergedParams.delaySend || 0)); mergedParams.flangerSend = Math.max(0, Math.min(100, mergedParams.flangerSend || 0)); mergedParams.punch = Math.max(0, Math.min(100, mergedParams.punch || 0));
                           const validWaves = ['sine', 'square', 'sawtooth', 'noise', 'random']; if (!validWaves.includes(mergedParams.waveform)) { mergedParams.waveform = 'sine'; }
                           delete mergedParams.lfoShape; delete mergedParams.lfoRate; delete mergedParams.lfoOscAmt; delete mergedParams.lfoLpAmt; delete mergedParams.lfoHpAmt; delete mergedParams.chorusSend; delete mergedParams.phaserSend;
                           const loadedSteps = loadedTrackData.steps; const mergedSteps = Array(32).fill(null).map((_, idx) => { const loadedStep = loadedSteps[idx]; const defaultStep = { active: false, velocity: 100, pitchOffset: 0 }; return loadedStep ? { ...defaultStep, ...loadedStep } : defaultStep; });
                           const isMutedState = loadedTrackData.isMuted || false; const isSoloedState = loadedTrackData.isSoloed || false;
                           newTracks.push({ id: i, name: `Track ${i + 1}`, params: mergedParams, steps: mergedSteps, isMuted: isMutedState, isSoloed: isSoloedState });
                       } else { newTracks.push({ id: i, name: `Track ${i + 1}`, params: this.getDefaultTrackParams(i), steps: Array(32).fill(null).map(() => ({ active: false, velocity: 100, pitchOffset: 0 })), isMuted: false, isSoloed: false }); if (i >= loadedData.tracks.length) console.log(`Init track ${i+1} to default.`); else console.warn(`Invalid data track ${i+1}, resetting.`); }
                  }
                  this.tracks = newTracks;
                  this.initSequencerUI(); this.updateUIForTrack(this.selectedTrackIndex); this.updateSliderAndNumber("seqLength", "seqLengthInput", "seqLengthLabel", newLength, ""); this.updateSequenceLengthUI(newLength); this.updateAllSoloMuteButtonsUI(); this.updatePitchControlsState();
                  console.log("State loaded successfully."); alert(`Loaded state from ${file.name}.${versionWarning}`);
              } catch (error) { console.error("Error loading state:", error, error.stack); alert(`Failed load state: ${error.message}\n${error.stack}`); } // Added stack trace
          };
          reader.onerror = (event) => { console.error("Error reading file:", event.target.error); alert(`Error reading file.`); };
          reader.readAsText(file);
      }
      updateAllSoloMuteButtonsUI() { for (let i = 0; i < this.numTracks; i++) { const muteBtn = document.getElementById(`mute-btn-${i}`); const soloBtn = document.getElementById(`solo-btn-${i}`); const track = this.tracks[i]; if (muteBtn && track) { muteBtn.classList.toggle('muted', track.isMuted); muteBtn.title = track.isMuted ? `Unmute T${i+1}` : `Mute T${i+1}`; } if (soloBtn && track) { soloBtn.classList.toggle('soloed', track.isSoloed); soloBtn.title = track.isSoloed ? `Unsolo T${i+1}` : `Solo T${i+1}`; } } }

      // --- Utility Functions ---
      makeDistortionCurve(amount) { const k = amount <= 0 ? 0.001 : amount * 2.5; const n_samples = 4096; const curve = new Float32Array(n_samples); const deg = Math.PI / 180; let x; for (let i = 0; i < n_samples; ++i) { x = i * 2 / n_samples - 1; curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x)); } return curve; }
      normalizeBuffer(audioBuffer) { let peak = 0; for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) { const data = audioBuffer.getChannelData(ch); for (let i = 0; i < data.length; i++) { peak = Math.max(peak, Math.abs(data[i])); } } if (peak < 1e-5) { console.log("Buffer peak near zero, skipping normalization."); return; } const scale = 1.0 / peak; console.log(`Normalizing: Peak=${peak.toFixed(4)}, Scale=${scale.toFixed(4)}`); for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) { const data = audioBuffer.getChannelData(ch); for (let i = 0; i < data.length; i++) { data[i] *= scale; } } }
      bufferToWave(abuffer, bitDepth = 24) { const numOfChannels = abuffer.numberOfChannels; const sampleRate = abuffer.sampleRate; const numSamples = abuffer.length; const bytesPerSample = bitDepth / 8; const blockAlign = numOfChannels * bytesPerSample; const byteRate = sampleRate * blockAlign; const dataSize = numSamples * blockAlign; const headerSize = 44; const totalSize = headerSize + dataSize; const buffer = new ArrayBuffer(totalSize); const view = new DataView(buffer); const writePCM = (offset, sample) => { sample = Math.max(-1, Math.min(1, sample)); if (bitDepth === 24) { let val = Math.round(sample * 8388607.0); view.setUint8(offset + 0, (val >> 0) & 0xFF); view.setUint8(offset + 1, (val >> 8) & 0xFF); view.setUint8(offset + 2, (val >> 16) & 0xFF); } else { let val = Math.round(sample * 32767.0); view.setInt16(offset, val, true); } }; this.writeString(view, 0, "RIFF"); view.setUint32(4, 36 + dataSize, true); this.writeString(view, 8, "WAVE"); this.writeString(view, 12, "fmt "); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numOfChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitDepth, true); this.writeString(view, 36, "data"); view.setUint32(40, dataSize, true); let offset = 44; for (let i = 0; i < numSamples; i++) { for (let ch = 0; ch < numOfChannels; ch++) { const channelData = abuffer.getChannelData(ch); writePCM(offset, channelData[i]); offset += bytesPerSample; } } return new Blob([buffer], { type: "audio/wav" }); }
      writeString(view, offset, str) { for (let i = 0; i < str.length; i++) { view.setUint8(offset + i, str.charCodeAt(i)); } }
      downloadBlob(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.style.display = "none"; a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100); }

      // --- Event Listener Setup ---
      setupEventListeners() { try { this.setupSaveLoadListeners(); this.setupTopBottomBarListeners(); this.setupSequencerControlListeners(); this.setupTrackSelectionListeners(); this.setupMuteButtonListeners(); this.setupSoloButtonListeners(); this.setupMasterEffectListeners(); this.setupParameterSyncListeners(); this.setupTempoLengthScopeListeners(); } catch(error) { console.error("Error setting up event listeners:", error); } }
      setupSaveLoadListeners() { document.getElementById('saveStateBtn')?.addEventListener('click', () => this.saveState()); const loadFileInput = document.getElementById('loadFileInput'); const loadBtn = document.getElementById('loadStateBtn'); if(loadFileInput && loadBtn) { loadBtn.addEventListener('click', () => { loadFileInput.click(); }); loadFileInput.addEventListener('change', (event) => { if (event.target.files.length > 0) { const file = event.target.files[0]; if (file.name.toLowerCase().endsWith('.krtz')) { this.loadState(file); } else { alert("Invalid file type: '.krtz' expected."); } } event.target.value = null; }); } }
      setupMasterEffectListeners() { try {
          const compThreshSlider = document.getElementById('compThreshold'); const compThreshInput = document.getElementById('compThresholdInput'); if(compThreshSlider && compThreshInput){ const updateCompThresh = (valStr) => { try{ const db = parseFloat(valStr); if(isNaN(db) || db < -60 || db > 0) return; this.masterCompressor.threshold.setTargetAtTime(db, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("compThreshold", "compThresholdInput", "compThresholdValue", db.toFixed(0), " dB"); }catch(e){console.error("Err CompThr:", e)} }; compThreshSlider.addEventListener('input', e => updateCompThresh(e.target.value)); compThreshInput.addEventListener('input', e => updateCompThresh(e.target.value)); }
          const compRatioSlider = document.getElementById('compRatio'); const compRatioInput = document.getElementById('compRatioInput'); if(compRatioSlider && compRatioInput){ const updateCompRatio = (valStr) => { try{ const ratio = parseFloat(valStr); if(isNaN(ratio) || ratio < 1 || ratio > 20) return; this.masterCompressor.ratio.setTargetAtTime(ratio, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("compRatio", "compRatioInput", "compRatioValue", ratio.toFixed(0), ":1"); }catch(e){console.error("Err CompRatio:", e)} }; compRatioSlider.addEventListener('input', e => updateCompRatio(e.target.value)); compRatioInput.addEventListener('input', e => updateCompRatio(e.target.value)); }
          const reverbPreDelaySlider = document.getElementById('masterReverbPreDelay'); if(reverbPreDelaySlider){ const updateReverbPre = (valStr) => { try{ const ms = parseInt(valStr); if (isNaN(ms) || ms < 0 || ms > 200) return; this.reverbPreDelay.delayTime.setTargetAtTime(ms / 1000.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterReverbPreDelay", "masterReverbPreDelayInput", "masterReverbPreDelayValue", ms, " ms"); }catch(e){console.error("Err PreDelay:",e)} }; reverbPreDelaySlider.addEventListener('input', e => updateReverbPre(e.target.value)); document.getElementById('masterReverbPreDelayInput')?.addEventListener('input', e => updateReverbPre(e.target.value)); }
          const reverbToneSlider = document.getElementById('masterReverbTone'); if(reverbToneSlider){ const updateReverbTone = (valStr) => { try{ const hz = parseInt(valStr); if (isNaN(hz) || hz < 100 || hz > 15000) return; this.reverbToneFilter.frequency.setTargetAtTime(hz, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterReverbTone", "masterReverbToneInput", "masterReverbToneValue", hz, " Hz"); }catch(e){console.error("Err Tone:",e)} }; reverbToneSlider.addEventListener('input', e => updateReverbTone(e.target.value)); document.getElementById('masterReverbToneInput')?.addEventListener('input', e => updateReverbTone(e.target.value)); }
          const reverbWetSlider = document.getElementById('masterReverbWet'); if(reverbWetSlider){ const updateReverbWet = (valStr) => { try{ const percent = parseInt(valStr); if (isNaN(percent) || percent < 0 || percent > 100) return; this.reverbWetGain.gain.setTargetAtTime(percent / 100.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterReverbWet", "masterReverbWetInput", "masterReverbWetValue", percent, "%"); }catch(e){console.error("Err RevWet:",e)} }; reverbWetSlider.addEventListener('input', e => updateReverbWet(e.target.value)); document.getElementById('masterReverbWetInput')?.addEventListener('input', e => updateReverbWet(e.target.value)); }
          const delayDivisionSelect = document.getElementById('masterDelayDivision'); if(delayDivisionSelect){ delayDivisionSelect.addEventListener('change', (e) => { try{ this.delayDivision = e.target.value; this.updateDelayTimeBasedOnTempo(); }catch(e){console.error("Err DelayDiv:",e)} }); }
          const delayFbSlider = document.getElementById('masterDelayFeedback'); if(delayFbSlider){ const updateDelayFb = (valStr) => { try{ const percent = parseInt(valStr); if (isNaN(percent) || percent < 0 || percent > 95) return; this.delayFeedbackGain.gain.setTargetAtTime(percent / 100.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterDelayFeedback", "masterDelayFeedbackInput", "masterDelayFeedbackValue", percent, "%"); }catch(e){console.error("Err DlyFb:",e)} }; delayFbSlider.addEventListener('input', e => updateDelayFb(e.target.value)); document.getElementById('masterDelayFeedbackInput')?.addEventListener('input', e => updateDelayFb(e.target.value)); }
          const delayWetSlider = document.getElementById('masterDelayWet'); if(delayWetSlider){ const updateDelayWet = (valStr) => { try{ const percent = parseInt(valStr); if (isNaN(percent) || percent < 0 || percent > 100) return; this.delayWetGain.gain.setTargetAtTime(percent / 100.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterDelayWet", "masterDelayWetInput", "masterDelayWetValue", percent, "%"); }catch(e){console.error("Err DlyWet:",e)} }; delayWetSlider.addEventListener('input', e => updateDelayWet(e.target.value)); document.getElementById('masterDelayWetInput')?.addEventListener('input', e => updateDelayWet(e.target.value)); }
          const flangerRateSlider = document.getElementById('masterFlangerRate'); if(flangerRateSlider){ const updateFlangerRate = (valStr) => { try{ const hz = parseFloat(valStr); if(isNaN(hz) || hz < 0.05 || hz > 5) return; this.flangerLFO.frequency.setTargetAtTime(hz, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterFlangerRate", "masterFlangerRateInput", "masterFlangerRateValue", hz.toFixed(2), " Hz"); }catch(e){console.error("Err FlgRate:",e)} }; flangerRateSlider.addEventListener('input', e => updateFlangerRate(e.target.value)); document.getElementById('masterFlangerRateInput')?.addEventListener('input', e => updateFlangerRate(e.target.value)); }
          const flangerDepthSlider = document.getElementById('masterFlangerDepth'); if(flangerDepthSlider){ const updateFlangerDepth = (valStr) => { try{ const ms = parseFloat(valStr); if(isNaN(ms) || ms < 0.1 || ms > 10) return; this.flangerLFODepth.gain.setTargetAtTime(ms / 1000.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterFlangerDepth", "masterFlangerDepthInput", "masterFlangerDepthValue", ms.toFixed(1), " ms"); }catch(e){console.error("Err FlgDepth:",e)} }; flangerDepthSlider.addEventListener('input', e => updateFlangerDepth(e.target.value)); document.getElementById('masterFlangerDepthInput')?.addEventListener('input', e => updateFlangerDepth(e.target.value)); }
          const flangerDelaySlider = document.getElementById('masterFlangerDelay'); if(flangerDelaySlider){ const updateFlangerDelay = (valStr) => { try{ const ms = parseFloat(valStr); if(isNaN(ms) || ms < 1 || ms > 20) return; this.flangerDelay.delayTime.setTargetAtTime(ms / 1000.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterFlangerDelay", "masterFlangerDelayInput", "masterFlangerDelayValue", ms.toFixed(1), " ms"); }catch(e){console.error("Err FlgDelay:",e)} }; flangerDelaySlider.addEventListener('input', e => updateFlangerDelay(e.target.value)); document.getElementById('masterFlangerDelayInput')?.addEventListener('input', e => updateFlangerDelay(e.target.value)); }
          const flangerFbSlider = document.getElementById('masterFlangerFeedback'); if(flangerFbSlider){ const updateFlangerFb = (valStr) => { try{ const percent = parseInt(valStr); if(isNaN(percent) || percent < -90 || percent > 90) return; this.flangerFeedback.gain.setTargetAtTime(percent / 100.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterFlangerFeedback", "masterFlangerFeedbackInput", "masterFlangerFeedbackValue", percent, " %"); }catch(e){console.error("Err FlgFb:",e)} }; flangerFbSlider.addEventListener('input', e => updateFlangerFb(e.target.value)); document.getElementById('masterFlangerFeedbackInput')?.addEventListener('input', e => updateFlangerFb(e.target.value)); }
          const flangerWetSlider = document.getElementById('masterFlangerWet'); if(flangerWetSlider){ const updateFlangerWet = (valStr) => { try{ const percent = parseInt(valStr); if(isNaN(percent) || percent < 0 || percent > 100) return; this.flangerWetGain.gain.setTargetAtTime(percent / 100.0, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterFlangerWet", "masterFlangerWetInput", "masterFlangerWetValue", percent, "%"); }catch(e){console.error("Err FlgWet:",e)} }; flangerWetSlider.addEventListener('input', e => updateFlangerWet(e.target.value)); document.getElementById('masterFlangerWetInput')?.addEventListener('input', e => updateFlangerWet(e.target.value)); }
          const masterVolSlider = document.getElementById('masterVolume'); if(masterVolSlider){ const updateMasterVol = (valStr) => { try{ const volumePercent = parseInt(valStr); if (isNaN(volumePercent) || volumePercent < 0 || volumePercent > 100) return; this.masterGain.gain.setTargetAtTime(volumePercent / 100, this.audioContext.currentTime, 0.01); this.updateSliderAndNumber("masterVolume", "masterVolumeInput", "masterVolumeValue", volumePercent, "%"); }catch(e){console.error("Err MstVol:",e)} }; masterVolSlider.addEventListener('input', e => updateMasterVol(e.target.value)); document.getElementById('masterVolumeInput')?.addEventListener('input', e => updateMasterVol(e.target.value)); }
       } catch (error) { console.error("Error setting up Master Effect listeners:", error); } }
      setupParameterSyncListeners() { try {
          this.syncAndStoreParam('punch', 'punchInput', 'punchValue', 'punch', ' %'); this.syncAndStoreParam('pitch', 'pitchInput', 'pitchValue', 'pitch', ' Hz', false); this.syncAndStoreParam('octaveSlider', null, 'octaveLabel', 'octave', '', false, i => this.octaveLabels[i]); this.syncAndStoreParam('oscLfoRate', 'oscLfoRateInput', 'oscLfoRateValue', 'oscLfoRate', ' Hz', true); this.syncAndStoreParam('oscLfoAmount', 'oscLfoAmountInput', 'oscLfoAmountValue', 'oscLfoAmount', ' %');
          this.syncAndStoreParam('ampAttack', 'ampAttackInput', 'ampAttackValue', 'ampAttack', ' ms'); this.syncAndStoreParam('ampDecay', 'ampDecayInput', 'ampDecayValue', 'ampDecay', ' ms'); this.syncAndStoreParam('ampSustain', 'ampSustainInput', 'ampSustainValue', 'ampSustain', ''); this.syncAndStoreParam('ampRelease', 'ampReleaseInput', 'ampReleaseValue', 'ampRelease', ' ms');
          this.syncAndStoreParam('cutoff', 'cutoffInput', 'cutoffValue', 'cutoff', ' Hz', false); this.syncAndStoreParam('resonance', 'resonanceInput', 'resonanceValue', 'resonance', '', true); this.syncAndStoreParam('filterEnv', 'filterEnvInput', 'filterEnvValue', 'filterEnv', ''); this.syncAndStoreParam('hpCutoff', 'hpCutoffInput', 'hpCutoffValue', 'hpCutoff', ' Hz', false); this.syncAndStoreParam('hpResonance', 'hpResonanceInput', 'hpResonanceValue', 'hpResonance', '', true); this.syncAndStoreParam('hpFilterEnv', 'hpFilterEnvInput', 'hpFilterEnvValue', 'hpFilterEnv', '');
          this.syncAndStoreParam('pitchEnvAmount', 'pitchEnvAmountInput', 'pitchEnvAmountValue', 'pitchEnvAmount', ''); this.syncAndStoreParam('pitchSpeed', 'pitchSpeedInput', 'pitchSpeedLabel', 'pitchSpeed', '%'); this.syncAndStoreParam('pitchAttack', 'pitchAttackInput', 'pitchAttackValue', 'pitchAttack', ' ms'); this.syncAndStoreParam('pitchDecay', 'pitchDecayInput', 'pitchDecayValue', 'pitchDecay', ' ms'); this.syncAndStoreParam('pitchSustain', 'pitchSustainInput', 'pitchSustainValue', 'pitchSustain', ''); this.syncAndStoreParam('pitchRelease', 'pitchReleaseInput', 'pitchReleaseValue', 'pitchRelease', ' ms');
          this.syncAndStoreParam('distortion', 'distortionInput', 'distortionValue', 'distortion', '%'); this.syncAndStoreParam('trackVolume', 'trackVolumeInput', 'trackVolumeValue', 'trackVolume', '%'); this.syncAndStoreParam('pan', 'panInput', 'panValue', 'pan', '');
          this.syncAndStoreParam('reverbSend', 'reverbSendInput', 'reverbSendValue', 'reverbSend', '%'); this.syncAndStoreParam('delaySend', 'delaySendInput', 'delaySendValue', 'delaySend', '%');
          this.syncAndStoreParam('flangerSend', 'flangerSendInput', 'flangerSendValue', 'flangerSend', '%');
          document.getElementById('waveform')?.addEventListener('change', (e) => { if (this.selectedTrackIndex >= 0 && this.selectedTrackIndex < this.numTracks) { this.tracks[this.selectedTrackIndex].params.waveform = e.target.value; this.updatePitchControlsState(); } });
          document.getElementById('oscLfoShape')?.addEventListener('change', (e) => { if (this.selectedTrackIndex >= 0 && this.selectedTrackIndex < this.numTracks) { this.tracks[this.selectedTrackIndex].params.oscLfoShape = e.target.value; } });
       } catch (error) { console.error("Error setting up Parameter Sync listeners:", error); } }
      setupTrackSelectionListeners() { document.querySelectorAll('.track-select-btn').forEach(btn => { btn.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.trackIndex); if (!isNaN(index)) this.updateUIForTrack(index); }); }); }
      setupMuteButtonListeners() { document.querySelectorAll('.mute-btn').forEach(button => { button.addEventListener('click', (e) => { try{ const trackIndex = parseInt(e.target.dataset.trackIndex); if (isNaN(trackIndex) || trackIndex < 0 || trackIndex >= this.numTracks || !this.tracks[trackIndex]) return; const track = this.tracks[trackIndex]; track.isMuted = !track.isMuted; this.updateAllSoloMuteButtonsUI(); } catch(err){console.error("Err Mute:",err)} }); }); }
      setupSoloButtonListeners() { document.querySelectorAll('.solo-btn').forEach(button => { button.addEventListener('click', (e) => { try{ const trackIndex = parseInt(e.target.dataset.trackIndex); if (isNaN(trackIndex) || trackIndex < 0 || trackIndex >= this.numTracks || !this.tracks[trackIndex]) return; const track = this.tracks[trackIndex]; const wasSoloed = track.isSoloed; if (!wasSoloed) { this.tracks.forEach((t, idx) => { if (idx !== trackIndex) t.isSoloed = false; }); } track.isSoloed = !wasSoloed; this.updateAllSoloMuteButtonsUI(); } catch(err){console.error("Err Solo:",err)} }); }); }
      setupSequencerControlListeners() { document.getElementById("seqPlayBtn")?.addEventListener("click", () => this.playSequencer()); document.getElementById("seqStopBtn")?.addEventListener("click", () => this.stopSequencer()); document.getElementById("seqRandomBtn")?.addEventListener("click", () => this.randomizeSelectedTrackSequence()); document.getElementById("seqRandomTonesBtn")?.addEventListener("click", () => this.randomizeSelectedTrackTones()); document.getElementById("seqClearBtn")?.addEventListener("click", () => this.clearSelectedTrackSequence()); document.getElementById("seqClearAllBtn")?.addEventListener("click", () => this.clearAllTrackSequences()); document.getElementById("seqExportBtn")?.addEventListener("click", () => this.exportSequence()); }
      setupTopBottomBarListeners() { document.getElementById("play")?.addEventListener("click", () => this.playTrackNote(this.selectedTrackIndex)); document.getElementById("generate")?.addEventListener("click", () => this.generateTrackWAV(this.selectedTrackIndex)); document.getElementById("playTopBtn")?.addEventListener("click", () => { this.playTrackNote(this.selectedTrackIndex); }); document.getElementById("generateTopBtn")?.addEventListener("click", () => { this.generateTrackWAV(this.selectedTrackIndex); }); document.getElementById("seqPlayTopBtn")?.addEventListener("click", () => { this.playSequencer(); }); document.getElementById("seqStopTopBtn")?.addEventListener("click", () => { this.stopSequencer(); }); document.getElementById("seqExportTopBtn")?.addEventListener("click", () => this.exportSequence()); }
      setupTempoLengthScopeListeners() { const tempoSlider = document.getElementById('tempo'); const tempoInput = document.getElementById('tempoInput'); const tempoLabel = document.getElementById('tempoValue'); if (tempoSlider && tempoInput && tempoLabel) { const updateTempo = (valStr) => { try{ const newTempo = parseInt(valStr); if (isNaN(newTempo) || newTempo < 40 || newTempo > 240) return; const wasPlaying = this.isPlayingSeq; if (wasPlaying) this.stopSequencer(); this.tempo = newTempo; tempoLabel.textContent = `${this.tempo} BPM`; if (tempoSlider.value != this.tempo) tempoSlider.value = this.tempo; if (tempoInput.value != this.tempo) tempoInput.value = this.tempo; this.updateDelayTimeBasedOnTempo(); if (wasPlaying) { setTimeout(() => { this.playSequencer(); }, 50); } }catch(e){console.error("Err Tempo:",e)} }; tempoSlider.addEventListener('input', (e) => updateTempo(e.target.value)); tempoInput.addEventListener('input', (e) => updateTempo(e.target.value)); } const seqLengthSlider = document.getElementById('seqLength'); const seqLengthInput = document.getElementById('seqLengthInput'); const seqLengthLabel = document.getElementById('seqLengthLabel'); if(seqLengthSlider && seqLengthInput && seqLengthLabel){ const updateLength = (valStr) => { try{ const newLength = parseInt(valStr); if (isNaN(newLength) || newLength < 1 || newLength > 32) return; seqLengthLabel.textContent = newLength; if (seqLengthSlider.value != newLength) seqLengthSlider.value = newLength; if (seqLengthInput.value != newLength) seqLengthInput.value = newLength; this.updateSequenceLengthUI(newLength); }catch(e){console.error("Err SeqLen:",e)} }; seqLengthSlider.addEventListener('input', (e) => updateLength(e.target.value)); seqLengthInput.addEventListener('input', (e) => updateLength(e.target.value)); } const scopeZoomSlider = document.getElementById('scopeZoom'); const scopeZoomInput = document.getElementById('scopeZoomInput'); const scopeZoomLabel = document.getElementById('scopeZoomLabel'); if(scopeZoomSlider && scopeZoomInput && scopeZoomLabel){ const updateScopeZoom = (valStr) => { try{ const newZoom = parseFloat(valStr); if (isNaN(newZoom) || newZoom < 0.1 || newZoom > 10) return; this.scopeZoom = newZoom; scopeZoomLabel.textContent = `${this.scopeZoom.toFixed(1)}x`; if (scopeZoomSlider.value != this.scopeZoom.toFixed(1)) scopeZoomSlider.value = this.scopeZoom.toFixed(1); if (scopeZoomInput.value != this.scopeZoom.toFixed(1)) scopeZoomInput.value = this.scopeZoom.toFixed(1); }catch(e){console.error("Err ScopeZoom:",e)} }; scopeZoomSlider.addEventListener('input', e => updateScopeZoom(e.target.value)); scopeZoomInput.addEventListener('input', e => updateScopeZoom(e.target.value)); } }
      updateDelayTimeBasedOnTempo() { try{ const division = this.delayDivision; const tempo = this.tempo; if (!division || !tempo || tempo <= 0) return; const secondsPerBeat = 60.0 / tempo; let timeMultiplier = 0.5; switch(division) { case '1/16': timeMultiplier = 0.25; break; case '1/16t': timeMultiplier = 0.25 * (2/3); break; case '1/16d': timeMultiplier = 0.25 * 1.5; break; case '1/8': timeMultiplier = 0.5; break; case '1/8t': timeMultiplier = 0.5 * (2/3); break; case '1/8d': timeMultiplier = 0.5 * 1.5; break; case '1/4': timeMultiplier = 1.0; break; case '1/4t': timeMultiplier = 1.0 * (2/3); break; case '1/4d': timeMultiplier = 1.0 * 1.5; break; case '1/2': timeMultiplier = 2.0; break; case '1/2t': timeMultiplier = 2.0 * (2/3); break; case '1/2d': timeMultiplier = 2.0 * 1.5; break; case '1/1': timeMultiplier = 4.0; break; case '1/1t': timeMultiplier = 4.0 * (2/3); break; case '1/1d': timeMultiplier = 4.0 * 1.5; break; default: timeMultiplier = 0.5; } let calculatedTime = secondsPerBeat * timeMultiplier; calculatedTime = Math.min(this.MAX_DELAY_TIME, Math.max(0.01, calculatedTime)); this.delayNode.delayTime.setTargetAtTime(calculatedTime, this.audioContext.currentTime, 0.01); const timeLabel = document.getElementById('masterDelayTimeSecondsLabel'); if (timeLabel) { timeLabel.textContent = `(${calculatedTime.toFixed(3)}s)`; } } catch(e){console.error("Err UpdateDelay:",e)} }

      // --- setupUI ---
      setupUI() { try {
          this.updateSliderAndNumber("tempo", "tempoInput", "tempoValue", this.tempo, " BPM"); this.updateSliderAndNumber("seqLength", "seqLengthInput", "seqLengthLabel", this.sequenceLength, ""); this.updateSliderAndNumber("scopeZoom", "scopeZoomInput", "scopeZoomLabel", this.scopeZoom.toFixed(1), "x"); this.updateSliderAndNumber("masterVolume", "masterVolumeInput", "masterVolumeValue", this.masterGain.gain.value * 100, "%"); this.updateSliderAndNumber("compThreshold", "compThresholdInput", "compThresholdValue", this.masterCompressor.threshold.value, " dB"); this.updateSliderAndNumber("compRatio", "compRatioInput", "compRatioValue", this.masterCompressor.ratio.value, ":1"); this.updateSliderAndNumber("masterReverbPreDelay", "masterReverbPreDelayInput", "masterReverbPreDelayValue", (this.reverbPreDelay.delayTime.value * 1000).toFixed(0), " ms"); this.updateSliderAndNumber("masterReverbTone", "masterReverbToneInput", "masterReverbToneValue", this.reverbToneFilter.frequency.value.toFixed(0), " Hz"); this.updateSliderAndNumber("masterReverbWet", "masterReverbWetInput", "masterReverbWetValue", (this.reverbWetGain.gain.value * 100).toFixed(0), "%"); document.getElementById('masterDelayDivision').value = this.delayDivision; this.updateDelayTimeBasedOnTempo(); this.updateSliderAndNumber("masterDelayFeedback", "masterDelayFeedbackInput", "masterDelayFeedbackValue", (this.delayFeedbackGain.gain.value * 100).toFixed(0), "%"); this.updateSliderAndNumber("masterDelayWet", "masterDelayWetInput", "masterDelayWetValue", (this.delayWetGain.gain.value * 100).toFixed(0), "%");
          this.updateSliderAndNumber("masterFlangerRate", "masterFlangerRateInput", "masterFlangerRateValue", this.flangerLFO.frequency.value.toFixed(2), " Hz"); this.updateSliderAndNumber("masterFlangerDepth", "masterFlangerDepthInput", "masterFlangerDepthValue", (this.flangerLFODepth.gain.value * 1000).toFixed(1), " ms"); this.updateSliderAndNumber("masterFlangerDelay", "masterFlangerDelayInput", "masterFlangerDelayValue", (this.flangerDelay.delayTime.value * 1000).toFixed(1), " ms"); this.updateSliderAndNumber("masterFlangerFeedback", "masterFlangerFeedbackInput", "masterFlangerFeedbackValue", (this.flangerFeedback.gain.value * 100).toFixed(0), " %"); this.updateSliderAndNumber("masterFlangerWet", "masterFlangerWetInput", "masterFlangerWetValue", (this.flangerWetGain.gain.value * 100).toFixed(0), "%");
        } catch (error) { console.error("Error setting up initial UI values:", error); }
       }
      drawScope() { const canvas = document.getElementById("oscilloscope"); if (!canvas) return; const canvasCtx = canvas.getContext("2d"); const bufferLength = this.analyser.fftSize; const dataArray = new Uint8Array(bufferLength); const draw = () => { requestAnimationFrame(draw); if (!canvas.clientWidth || !canvas.clientHeight) return; if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; } try { this.analyser.getByteTimeDomainData(dataArray); } catch(e) { return; } canvasCtx.fillStyle = "#2E2E2E"; canvasCtx.fillRect(0, 0, canvas.width, canvas.height); canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = "#BB86FC"; canvasCtx.beginPath(); const sliceWidth = canvas.width / bufferLength; let x = 0; for (let i = 0; i < bufferLength; i++) { const v = (dataArray[i] / 128.0) - 1.0; const y = (canvas.height / 2) + (v * canvas.height / 2 * this.scopeZoom); if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y); x += sliceWidth; } canvasCtx.stroke(); }; draw(); }


    } // End DrumSynth Class

    window.addEventListener("load", () => { setTimeout(() => { try { window.drumMachine = new DrumSynth(); console.log("Kretz 8-Track Drum Machine v2.16 beta (Save Fix) Initialized"); } catch (error) { console.error("Failed to instantiate DrumSynth:", error); document.body.innerHTML = `<h2 style="color:red; padding: 20px;">Fatal Error Initializing Synth. Check Console.</h2><pre>${error.stack}</pre>`; } }, 100); });
</script>

</body>
</html>
